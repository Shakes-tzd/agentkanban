# ==============================================================================
# IJOKA IMPLEMENTATION PLAN
# ==============================================================================
# 
# Project Rename: AgentKanban → Ijoka
# Meaning: "Ijoka" is Zulu for "yoke" - yoking AI agents together for coordinated work
#
# This plan is designed to be executed by Claude Code in phases.
# Each phase is self-contained and can be completed independently.
# 
# Generated: 2025-12-08
# Target Version: 1.0.0
# ==============================================================================

meta:
  project_name: Ijoka
  previous_name: AgentKanban
  tagline: "Unified observability and orchestration for AI coding agents"
  version: 1.0.0
  repository: https://github.com/yourusername/ijoka
  
  key_architectural_decisions:
    - decision: "Eliminate feature_list.json entirely"
      rationale: |
        The JSON file creates sync issues, lost updates, and state conflicts.
        Graph DB becomes the single source of truth.
        Agents interact via MCP tools, never via file mutations.
      migration: "Phase 1 - Database Architecture"
      
    - decision: "Graph DB (Neo4j/Memgraph) as source of truth"
      rationale: |
        Relationships between features, events, sessions, and insights are natural graphs.
        Enables cross-project pattern learning and dependency tracking.
        Event sourcing fits naturally with graph temporal queries.
      migration: "Phase 1 - Database Architecture"
      
    - decision: "SQLite as local read cache only"
      rationale: |
        Tauri needs fast local reads for UI responsiveness.
        SQLite is already integrated and performant.
        Cache syncs from Graph DB, never written to directly by agents.
      migration: "Phase 1 - Database Architecture"
      
    - decision: "MCP server as universal agent interface"
      rationale: |
        MCP is the de facto standard for agent-tool integration.
        All major CLI agents (Claude Code, Gemini, Codex) support MCP.
        Tiered tool loading minimizes context overhead.
      migration: "Phase 2 - MCP Server"
      
    - decision: "Event sourcing for state management"
      rationale: |
        Append-only events eliminate lost updates and state conflicts.
        Full history automatically for debugging and analytics.
        Multi-agent safe (each agent appends, never overwrites).
      migration: "Phase 3 - Event Sourcing"
      
    - decision: "Claude Code as primary integration"
      rationale: |
        Most mature hooks system, best terminal UX, strong benchmarks.
        Hooks enable deep integration (intent detection, rules injection).
        Gemini/Codex supported via MCP passthrough.
      migration: "Phase 5 - Plugin Consolidation"

  principles:
    dry:
      description: Don't Repeat Yourself - extract reusable components
      enforcement:
        - "No copy-paste code - extract to shared modules"
        - "Component props for configuration, not duplication"
        - "Shared TypeScript interfaces in packages/shared/"
        - "Python base classes for hook scripts"
        - "Rust traits for database operations"
      
    type_safety:
      description: Full type annotations everywhere, validated at boundaries
      tools:
        typescript:
          strict_mode: true
          no_any: true
          no_implicit_any: true
          strict_null_checks: true
        python:
          type_hints: required
          validation: Pydantic v2
          runtime_checking: true
        rust:
          clippy: pedantic
          deny_warnings: true
    
    component_architecture:
      description: Small, focused, composable components
      vue_patterns:
        - "Single responsibility per component (<200 lines)"
        - "Props for configuration (with TypeScript interfaces)"
        - "Events for parent communication (typed emits)"
        - "Slots for flexible content injection"
        - "Composables for shared stateful logic"
        - "Provide/inject for deep prop drilling avoidance"
      file_naming:
        components: PascalCase.vue
        composables: useCamelCase.ts
        types: camelCase.types.ts
        utilities: camelCase.utils.ts
        
    error_handling:
      description: Explicit error handling, no silent failures
      patterns:
        rust: "Result<T, E> with proper error types, anyhow for context"
        typescript: "Either pattern or explicit error returns, no throw in library code"
        python: "Custom exception hierarchy, never bare except"

# ==============================================================================
# PHASE 0: RENAME PROJECT
# ==============================================================================
# Priority: Critical (do first to avoid confusion)
# Estimated Time: 2-4 hours
# Dependencies: None
# ==============================================================================

phase_0_rename:
  name: "Rename AgentKanban to Ijoka"
  priority: critical
  estimated_hours: 4
  dependencies: []
  
  description: |
    Rename all references from AgentKanban to Ijoka across the entire codebase.
    This includes package names, database paths, CLI commands, and documentation.
    Implement migration logic for existing users.
    
  pre_flight_checks:
    - "Ensure all changes are committed before starting"
    - "Create a backup branch: git checkout -b backup/agentkanban-final"
    - "Note any running instances of the app"
    
  tasks:
    - id: rename-01
      name: "Update root package.json"
      file: package.json
      changes:
        - field: name
          old: "agentkanban"
          new: "ijoka"
        - field: description
          old: "Unified observability and task management system for AI coding agents"
          new: "Unified observability and orchestration for AI coding agents - yoking agents together"
        - field: repository.url
          pattern: "agentkanban"
          replacement: "ijoka"
          
    - id: rename-02
      name: "Update apps/desktop/package.json"
      file: apps/desktop/package.json
      changes:
        - field: name
          old: "agentkanban-desktop"
          new: "ijoka-desktop"
        - field: productName
          old: "AgentKanban"
          new: "Ijoka"
          
    - id: rename-03
      name: "Update packages/claude-plugin/package.json"
      file: packages/claude-plugin/package.json
      changes:
        - field: name
          old: "agentkanban-plugin"
          new: "ijoka-plugin"
        - field: description
          pattern: "AgentKanban"
          replacement: "Ijoka"
          
    - id: rename-04
      name: "Update Cargo.toml"
      file: apps/desktop/src-tauri/Cargo.toml
      changes:
        - section: package
          field: name
          new: "ijoka"
        - section: package
          field: description
          new: "Ijoka - Unified observability and orchestration for AI coding agents"
        - section: "tauri-plugin"
          field: identifier
          new: "com.ijoka.app"
          
    - id: rename-05
      name: "Update tauri.conf.json"
      file: apps/desktop/src-tauri/tauri.conf.json
      changes:
        - path: "$.productName"
          new: "Ijoka"
        - path: "$.identifier"
          new: "com.ijoka.app"
        - path: "$.app.windows[0].title"
          new: "Ijoka"
        - path: "$.bundle.identifier"
          new: "com.ijoka.app"
          
    - id: rename-06
      name: "Update Rust source files - paths and constants"
      files:
        - apps/desktop/src-tauri/src/db.rs
        - apps/desktop/src-tauri/src/main.rs
        - apps/desktop/src-tauri/src/watcher.rs
        - apps/desktop/src-tauri/src/server.rs
        - apps/desktop/src-tauri/src/commands.rs
        - apps/desktop/src-tauri/src/plugin_manager.rs
      changes:
        - pattern: '".agentkanban"'
          replacement: '".ijoka"'
        - pattern: '"agentkanban.db"'
          replacement: '"ijoka.db"'
        - pattern: '"AgentKanban"'
          replacement: '"Ijoka"'
        - pattern: "agentkanban"
          replacement: "ijoka"
          context: "identifiers and paths only, not URLs or docs"
          
    - id: rename-07
      name: "Add database migration logic"
      file: apps/desktop/src-tauri/src/db.rs
      action: add_function
      code: |
        /// Migrate database from AgentKanban to Ijoka if needed
        pub fn migrate_from_legacy() -> Result<(), Box<dyn std::error::Error>> {
            let home = dirs::home_dir().ok_or("No home directory")?;
            let legacy_dir = home.join(".agentkanban");
            let legacy_db = legacy_dir.join("agentkanban.db");
            let new_dir = home.join(".ijoka");
            let new_db = new_dir.join("ijoka.db");
            
            // Only migrate if legacy exists and new doesn't
            if legacy_db.exists() && !new_db.exists() {
                tracing::info!("Migrating database from AgentKanban to Ijoka...");
                
                // Create new directory
                std::fs::create_dir_all(&new_dir)?;
                
                // Copy database file
                std::fs::copy(&legacy_db, &new_db)?;
                
                // Copy WAL and SHM files if they exist
                let legacy_wal = legacy_dir.join("agentkanban.db-wal");
                let legacy_shm = legacy_dir.join("agentkanban.db-shm");
                if legacy_wal.exists() {
                    std::fs::copy(&legacy_wal, new_dir.join("ijoka.db-wal"))?;
                }
                if legacy_shm.exists() {
                    std::fs::copy(&legacy_shm, new_dir.join("ijoka.db-shm"))?;
                }
                
                tracing::info!("Migration complete. Legacy data preserved at {:?}", legacy_dir);
            }
            
            Ok(())
        }
      call_site: "Call migrate_from_legacy() at start of init_database()"
      
    - id: rename-08
      name: "Update Python hook scripts - paths and constants"
      files:
        - packages/claude-plugin/hooks/scripts/db_helper.py
        - packages/claude-plugin/hooks/scripts/session-start.py
        - packages/claude-plugin/hooks/scripts/session-end.py
        - packages/claude-plugin/hooks/scripts/track-event.py
        - packages/claude-plugin/hooks/scripts/smart-feature-match.py
        - packages/claude-plugin/hooks/scripts/*.py
      changes:
        - pattern: '".agentkanban"'
          replacement: '".ijoka"'
        - pattern: '"agentkanban.db"'
          replacement: '"ijoka.db"'
        - pattern: "AGENTKANBAN_"
          replacement: "IJOKA_"
        - pattern: "agentkanban"
          replacement: "ijoka"
          context: "paths and identifiers"
        - pattern: "AgentKanban"
          replacement: "Ijoka"
          context: "display names and comments"
          
    - id: rename-09
      name: "Update hooks.json environment variables"
      file: packages/claude-plugin/hooks/hooks.json
      changes:
        - pattern: "AGENTKANBAN_"
          replacement: "IJOKA_"
          
    - id: rename-10
      name: "Update Vue components - display text"
      files:
        - apps/desktop/src/App.vue
        - apps/desktop/src/components/*.vue
      changes:
        - pattern: "AgentKanban"
          replacement: "Ijoka"
        - pattern: "agentkanban"
          replacement: "ijoka"
          context: "CSS classes and identifiers"
          
    - id: rename-11
      name: "Update TypeScript files"
      files:
        - apps/desktop/src/**/*.ts
        - apps/desktop/src/**/*.d.ts
      changes:
        - pattern: "AgentKanban"
          replacement: "Ijoka"
        - pattern: "agentkanban"
          replacement: "ijoka"
          
    - id: rename-12
      name: "Update plugin commands"
      files:
        - packages/claude-plugin/commands/*.md
      changes:
        - pattern: "AgentKanban"
          replacement: "Ijoka"
        - pattern: "agentkanban"
          replacement: "ijoka"
        - pattern: "/update-plugin"
          note: "Consider renaming to /ijoka-update or keeping generic"
          
    - id: rename-13
      name: "Update skills"
      files:
        - packages/claude-plugin/skills/**/*.md
      changes:
        - pattern: "AgentKanban"
          replacement: "Ijoka"
        - pattern: "agentkanban"
          replacement: "ijoka"
          
    - id: rename-14
      name: "Update README and documentation"
      files:
        - README.md
        - docs/**/*.md
        - packages/claude-plugin/README.md
        - CONTRIBUTING.md
        - CHANGELOG.md
      changes:
        - pattern: "AgentKanban"
          replacement: "Ijoka"
        - pattern: "agentkanban"
          replacement: "ijoka"
        - pattern: "agent-kanban"
          replacement: "ijoka"
          
    - id: rename-15
      name: "Update .github workflows if present"
      files:
        - .github/workflows/*.yml
        - .github/workflows/*.yaml
      changes:
        - pattern: "agentkanban"
          replacement: "ijoka"
        - pattern: "AgentKanban"
          replacement: "Ijoka"
          
    - id: rename-16
      name: "Rename directories if needed"
      commands:
        - description: "Rename plugin directory"
          check: "Only if directory is named agentkanban-plugin"
          command: "git mv packages/agentkanban-plugin packages/ijoka-plugin"
          conditional: true
          
    - id: rename-17
      name: "Update window title in Rust"
      file: apps/desktop/src-tauri/src/main.rs
      search_patterns:
        - '"AgentKanban"'
        - "AgentKanban"
      replacement: '"Ijoka"'

  verification:
    commands:
      - name: "Check for remaining AgentKanban references"
        command: |
          grep -r "AgentKanban" --include="*.rs" --include="*.vue" --include="*.ts" \
            --include="*.py" --include="*.json" --include="*.toml" --include="*.md" \
            --exclude-dir=node_modules --exclude-dir=target --exclude-dir=dist .
        expected: "No matches except in migration comments or changelog"
        
      - name: "Check for remaining agentkanban references"
        command: |
          grep -r "agentkanban" --include="*.rs" --include="*.vue" --include="*.ts" \
            --include="*.py" --include="*.json" --include="*.toml" \
            --exclude-dir=node_modules --exclude-dir=target --exclude-dir=dist .
        expected: "No matches except in migration code or URLs"
        
      - name: "Verify TypeScript compiles"
        command: "pnpm typecheck"
        expected: "No errors"
        
      - name: "Verify Rust compiles"
        command: "cd apps/desktop/src-tauri && cargo check"
        expected: "No errors"
        
      - name: "Verify app starts"
        command: "pnpm dev"
        expected: "App launches with 'Ijoka' title"

  rollback:
    description: "If issues arise, restore from backup branch"
    command: "git checkout backup/agentkanban-final"


# ==============================================================================
# PHASE 1: DATABASE ARCHITECTURE
# ==============================================================================
# Priority: High (foundation for all other changes)
# Estimated Time: 8-12 hours
# Dependencies: Phase 0 (Rename)
# ==============================================================================

phase_1_database:
  name: "Database Architecture - Graph DB as Source of Truth"
  priority: high
  estimated_hours: 12
  dependencies:
    - phase_0_rename
    
  description: |
    Migrate from SQLite + feature_list.json to Graph DB (source of truth) + SQLite (cache).
    
    CRITICAL: feature_list.json is ELIMINATED. Agents interact via MCP tools only.
    
    Architecture:
    ┌─────────────────────────────────────────────────────────────┐
    │                    GRAPH DATABASE                           │
    │                 (Neo4j or Memgraph)                         │
    │                 SOURCE OF TRUTH                             │
    │                                                             │
    │  Nodes: Project, Feature, Event, Session, Insight, Rule    │
    │  Edges: BELONGS_TO, TRIGGERED_BY, LINKED_TO, LEARNED_FROM  │
    └─────────────────────────────────────────────────────────────┘
                              │
                              │ Sync (one-way)
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │                      SQLITE CACHE                           │
    │                   (Tauri local DB)                          │
    │                   READ-ONLY CACHE                           │
    │                                                             │
    │  Fast queries for UI rendering                              │
    │  Synced from Graph DB on changes                            │
    │  Never written to by agents                                 │
    └─────────────────────────────────────────────────────────────┘
    
  architecture:
    graph_database:
      options:
        - name: Neo4j
          pros:
            - Mature, well-documented
            - Cypher query language is powerful
            - Good desktop and cloud options
            - Strong Python and Rust drivers
          cons:
            - Resource heavy for embedded use
            - Requires Java runtime
          recommendation: "Good for production, cloud-hosted"
          
        - name: Memgraph
          pros:
            - Compatible with Neo4j Cypher
            - Lighter weight, C++ based
            - In-memory with persistence
            - Better for embedded/local use
          cons:
            - Smaller community
            - Fewer integrations
          recommendation: "Good for local-first architecture"
          
        - name: SurrealDB
          pros:
            - Multi-model (document, graph, relational)
            - Rust-native
            - Can embed in Tauri app
            - SQL-like syntax
          cons:
            - Newer, less battle-tested
            - Graph features less mature than Neo4j
          recommendation: "Consider for single-binary deployment"
          
      selected: Memgraph
      rationale: |
        Memgraph provides Neo4j compatibility (Cypher queries) with lighter footprint.
        Can run locally for development and scale to cloud for teams.
        Compatible with existing tooling and patterns.
        
    sqlite_cache:
      purpose: "Fast local reads for Tauri UI"
      sync_strategy: "Pull from Graph DB on app start, subscribe to changes"
      write_policy: "NEVER write directly - all writes go through Graph DB"
      
  graph_schema:
    nodes:
      Project:
        properties:
          - { name: id, type: string, required: true, description: "UUID" }
          - { name: path, type: string, required: true, description: "Filesystem path" }
          - { name: name, type: string, required: true, description: "Display name" }
          - { name: description, type: string, required: false }
          - { name: created_at, type: datetime, required: true }
          - { name: updated_at, type: datetime, required: true }
          - { name: settings, type: json, required: false, description: "Project-specific settings" }
        indexes:
          - property: path
            unique: true
            
      Feature:
        properties:
          - { name: id, type: string, required: true, description: "UUID" }
          - { name: description, type: string, required: true }
          - { name: category, type: string, required: true, enum: [functional, ui, security, performance, documentation, testing, infrastructure, refactoring] }
          - { name: status, type: string, required: true, enum: [pending, in_progress, blocked, complete], default: pending }
          - { name: priority, type: integer, required: false, default: 0, description: "Higher = more important" }
          - { name: steps, type: "string[]", required: false, description: "Verification steps" }
          - { name: completion_criteria, type: json, required: false }
          - { name: created_at, type: datetime, required: true }
          - { name: updated_at, type: datetime, required: true }
          - { name: completed_at, type: datetime, required: false }
          - { name: work_count, type: integer, default: 0 }
          - { name: assigned_agent, type: string, required: false }
          - { name: confidence, type: float, required: false, description: "0-1 completion confidence" }
          - { name: token_cost, type: integer, required: false }
          - { name: error_count, type: integer, default: 0 }
        indexes:
          - property: status
          - property: category
          - compound: [status, priority]
          
      Event:
        properties:
          - { name: id, type: string, required: true, description: "UUID" }
          - { name: event_type, type: string, required: true }
          - { name: tool_name, type: string, required: false }
          - { name: payload, type: json, required: false }
          - { name: summary, type: string, required: false, description: "Human-readable summary" }
          - { name: timestamp, type: datetime, required: true }
          - { name: success, type: boolean, required: false }
          - { name: duration_ms, type: integer, required: false }
          - { name: tokens_used, type: integer, required: false }
        indexes:
          - property: event_type
          - property: timestamp
          - property: tool_name
          
      Session:
        properties:
          - { name: id, type: string, required: true, description: "UUID" }
          - { name: agent, type: string, required: true, description: "claude-code, gemini-cli, codex-cli" }
          - { name: status, type: string, required: true, enum: [active, ended, stale] }
          - { name: started_at, type: datetime, required: true }
          - { name: ended_at, type: datetime, required: false }
          - { name: last_activity, type: datetime, required: true }
          - { name: event_count, type: integer, default: 0 }
          - { name: model, type: string, required: false }
          - { name: is_subagent, type: boolean, default: false }
          - { name: parent_session_id, type: string, required: false }
        indexes:
          - property: status
          - property: agent
          - property: started_at
          
      Insight:
        description: "Reusable learnings extracted from sessions"
        properties:
          - { name: id, type: string, required: true }
          - { name: description, type: string, required: true }
          - { name: pattern_type, type: string, required: true, enum: [solution, anti_pattern, best_practice, tool_usage] }
          - { name: tags, type: "string[]", required: false }
          - { name: created_at, type: datetime, required: true }
          - { name: usage_count, type: integer, default: 0 }
          - { name: effectiveness_score, type: float, required: false }
        indexes:
          - property: pattern_type
          - property: tags
          
      Rule:
        description: "Enforced behaviors derived from repeated instructions"
        properties:
          - { name: id, type: string, required: true }
          - { name: name, type: string, required: true }
          - { name: description, type: string, required: true }
          - { name: trigger, type: json, required: true, description: "When to apply rule" }
          - { name: action, type: json, required: true, description: "What to do" }
          - { name: scope, type: string, required: true, enum: [global, project, feature] }
          - { name: enforcement, type: string, required: true, enum: [hook, prompt_inject, reminder] }
          - { name: enabled, type: boolean, default: true }
          - { name: created_at, type: datetime, required: true }
          - { name: triggered_count, type: integer, default: 0 }
          - { name: source_instruction_count, type: integer, description: "Times user gave this instruction before promotion" }
        indexes:
          - property: scope
          - property: enabled
          
    relationships:
      - type: BELONGS_TO
        from: Feature
        to: Project
        properties: []
        
      - type: IN_PROJECT
        from: Session
        to: Project
        properties: []
        
      - type: TRIGGERED_BY
        from: Event
        to: Session
        properties: []
        
      - type: LINKED_TO
        from: Event
        to: Feature
        properties:
          - { name: confidence, type: float, description: "How confident the link is" }
          - { name: linked_by, type: string, enum: [auto, manual, agent] }
          - { name: linked_at, type: datetime }
          
      - type: DEPENDS_ON
        from: Feature
        to: Feature
        properties:
          - { name: dependency_type, type: string, enum: [blocks, requires, related] }
          
      - type: LEARNED_FROM
        from: Insight
        to: Event
        properties:
          - { name: extracted_at, type: datetime }
          
      - type: APPLIES_TO
        from: Rule
        to: Project
        properties: []
        description: "Project-scoped rules"
        
      - type: DERIVED_FROM
        from: Rule
        to: Insight
        properties: []
        description: "Rule created from insight pattern"

  tasks:
    - id: db-01
      name: "Create packages/graph-db directory structure"
      type: create_directory
      structure:
        packages/graph-db/:
          - src/
          - src/schema/
          - src/queries/
          - src/sync/
          - tests/
          - package.json
          - tsconfig.json
          - README.md
          
    - id: db-02
      name: "Create graph database connection module"
      file: packages/graph-db/src/connection.ts
      content: |
        /**
         * Graph Database Connection Module
         * 
         * Provides connection management for Memgraph/Neo4j.
         * Supports both local development and cloud deployment.
         */
        
        import { Driver, Session, auth } from 'neo4j-driver';
        import type { Config, ConnectionPool } from './types';
        
        export interface GraphDBConfig {
          uri: string;           // bolt://localhost:7687
          username?: string;
          password?: string;
          database?: string;     // Default: 'ijoka'
          maxConnectionPoolSize?: number;
          connectionTimeout?: number;
        }
        
        export class GraphDBConnection {
          private driver: Driver | null = null;
          private config: GraphDBConfig;
          
          constructor(config: GraphDBConfig) {
            this.config = {
              maxConnectionPoolSize: 50,
              connectionTimeout: 30000,
              database: 'ijoka',
              ...config
            };
          }
          
          async connect(): Promise<void> {
            const { uri, username, password, maxConnectionPoolSize, connectionTimeout } = this.config;
            
            this.driver = neo4j.driver(
              uri,
              username && password ? auth.basic(username, password) : auth.basic('', ''),
              {
                maxConnectionPoolSize,
                connectionAcquisitionTimeout: connectionTimeout,
              }
            );
            
            // Verify connectivity
            await this.driver.verifyConnectivity();
          }
          
          async disconnect(): Promise<void> {
            if (this.driver) {
              await this.driver.close();
              this.driver = null;
            }
          }
          
          getSession(mode: 'READ' | 'WRITE' = 'WRITE'): Session {
            if (!this.driver) {
              throw new Error('Not connected to graph database');
            }
            return this.driver.session({
              database: this.config.database,
              defaultAccessMode: mode === 'READ' ? neo4j.session.READ : neo4j.session.WRITE
            });
          }
          
          async runQuery<T>(
            cypher: string, 
            params?: Record<string, unknown>,
            mode: 'READ' | 'WRITE' = 'READ'
          ): Promise<T[]> {
            const session = this.getSession(mode);
            try {
              const result = await session.run(cypher, params);
              return result.records.map(record => record.toObject() as T);
            } finally {
              await session.close();
            }
          }
          
          async runTransaction<T>(
            work: (tx: Transaction) => Promise<T>
          ): Promise<T> {
            const session = this.getSession('WRITE');
            try {
              return await session.executeWrite(work);
            } finally {
              await session.close();
            }
          }
        }
        
        // Singleton for app-wide use
        let connection: GraphDBConnection | null = null;
        
        export function getConnection(): GraphDBConnection {
          if (!connection) {
            throw new Error('Graph database not initialized. Call initGraphDB first.');
          }
          return connection;
        }
        
        export async function initGraphDB(config: GraphDBConfig): Promise<GraphDBConnection> {
          connection = new GraphDBConnection(config);
          await connection.connect();
          return connection;
        }
        
        export async function closeGraphDB(): Promise<void> {
          if (connection) {
            await connection.disconnect();
            connection = null;
          }
        }
        
    - id: db-03
      name: "Create schema initialization queries"
      file: packages/graph-db/src/schema/init.cypher
      content: |
        // ==============================================================================
        // IJOKA GRAPH DATABASE SCHEMA
        // ==============================================================================
        // Run this to initialize a fresh database or verify schema exists.
        // Idempotent - safe to run multiple times.
        // ==============================================================================
        
        // Create constraints (also creates indexes)
        CREATE CONSTRAINT project_id IF NOT EXISTS FOR (p:Project) REQUIRE p.id IS UNIQUE;
        CREATE CONSTRAINT project_path IF NOT EXISTS FOR (p:Project) REQUIRE p.path IS UNIQUE;
        CREATE CONSTRAINT feature_id IF NOT EXISTS FOR (f:Feature) REQUIRE f.id IS UNIQUE;
        CREATE CONSTRAINT event_id IF NOT EXISTS FOR (e:Event) REQUIRE e.id IS UNIQUE;
        CREATE CONSTRAINT session_id IF NOT EXISTS FOR (s:Session) REQUIRE s.id IS UNIQUE;
        CREATE CONSTRAINT insight_id IF NOT EXISTS FOR (i:Insight) REQUIRE i.id IS UNIQUE;
        CREATE CONSTRAINT rule_id IF NOT EXISTS FOR (r:Rule) REQUIRE r.id IS UNIQUE;
        
        // Create additional indexes for common queries
        CREATE INDEX feature_status IF NOT EXISTS FOR (f:Feature) ON (f.status);
        CREATE INDEX feature_category IF NOT EXISTS FOR (f:Feature) ON (f.category);
        CREATE INDEX event_type IF NOT EXISTS FOR (e:Event) ON (e.event_type);
        CREATE INDEX event_timestamp IF NOT EXISTS FOR (e:Event) ON (e.timestamp);
        CREATE INDEX session_status IF NOT EXISTS FOR (s:Session) ON (s.status);
        CREATE INDEX session_agent IF NOT EXISTS FOR (s:Session) ON (s.agent);
        CREATE INDEX rule_scope IF NOT EXISTS FOR (r:Rule) ON (r.scope);
        CREATE INDEX rule_enabled IF NOT EXISTS FOR (r:Rule) ON (r.enabled);
        
    - id: db-04
      name: "Create feature repository"
      file: packages/graph-db/src/repositories/feature.repository.ts
      content: |
        /**
         * Feature Repository
         * 
         * All feature CRUD operations against the graph database.
         * This is the ONLY way to read/write features - no direct file access.
         */
        
        import { v4 as uuidv4 } from 'uuid';
        import { getConnection } from '../connection';
        import type { Feature, FeatureStatus, FeatureCategory } from '../types';
        
        export interface CreateFeatureInput {
          projectId: string;
          description: string;
          category: FeatureCategory;
          steps?: string[];
          priority?: number;
          completionCriteria?: Record<string, unknown>;
        }
        
        export interface UpdateFeatureInput {
          description?: string;
          category?: FeatureCategory;
          status?: FeatureStatus;
          steps?: string[];
          priority?: number;
          completionCriteria?: Record<string, unknown>;
          assignedAgent?: string;
          confidence?: number;
          tokenCost?: number;
          workCount?: number;
        }
        
        export class FeatureRepository {
          
          /**
           * Create a new feature and link it to a project
           */
          async create(input: CreateFeatureInput): Promise<Feature> {
            const conn = getConnection();
            const id = uuidv4();
            const now = new Date().toISOString();
            
            const result = await conn.runQuery<{ f: Feature }>(
              `
              MATCH (p:Project {id: $projectId})
              CREATE (f:Feature {
                id: $id,
                description: $description,
                category: $category,
                status: 'pending',
                steps: $steps,
                priority: $priority,
                completion_criteria: $completionCriteria,
                created_at: datetime($now),
                updated_at: datetime($now),
                work_count: 0,
                error_count: 0
              })
              CREATE (f)-[:BELONGS_TO]->(p)
              RETURN f
              `,
              {
                projectId: input.projectId,
                id,
                description: input.description,
                category: input.category,
                steps: input.steps || [],
                priority: input.priority || 0,
                completionCriteria: JSON.stringify(input.completionCriteria || {}),
                now
              },
              'WRITE'
            );
            
            return result[0].f;
          }
          
          /**
           * Get a feature by ID
           */
          async getById(id: string): Promise<Feature | null> {
            const conn = getConnection();
            const result = await conn.runQuery<{ f: Feature }>(
              `MATCH (f:Feature {id: $id}) RETURN f`,
              { id }
            );
            return result[0]?.f || null;
          }
          
          /**
           * Get all features for a project
           */
          async getByProject(projectId: string): Promise<Feature[]> {
            const conn = getConnection();
            const result = await conn.runQuery<{ f: Feature }>(
              `
              MATCH (f:Feature)-[:BELONGS_TO]->(p:Project {id: $projectId})
              RETURN f
              ORDER BY f.priority DESC, f.created_at ASC
              `,
              { projectId }
            );
            return result.map(r => r.f);
          }
          
          /**
           * Get features by status
           */
          async getByStatus(projectId: string, status: FeatureStatus): Promise<Feature[]> {
            const conn = getConnection();
            const result = await conn.runQuery<{ f: Feature }>(
              `
              MATCH (f:Feature)-[:BELONGS_TO]->(p:Project {id: $projectId})
              WHERE f.status = $status
              RETURN f
              ORDER BY f.priority DESC, f.created_at ASC
              `,
              { projectId, status }
            );
            return result.map(r => r.f);
          }
          
          /**
           * Get the next feature to work on (highest priority pending)
           */
          async getNextFeature(projectId: string): Promise<Feature | null> {
            const conn = getConnection();
            const result = await conn.runQuery<{ f: Feature }>(
              `
              MATCH (f:Feature)-[:BELONGS_TO]->(p:Project {id: $projectId})
              WHERE f.status = 'pending'
              // Exclude features with unresolved dependencies
              AND NOT EXISTS {
                MATCH (f)-[:DEPENDS_ON {dependency_type: 'blocks'}]->(dep:Feature)
                WHERE dep.status <> 'complete'
              }
              RETURN f
              ORDER BY f.priority DESC, f.created_at ASC
              LIMIT 1
              `,
              { projectId }
            );
            return result[0]?.f || null;
          }
          
          /**
           * Update a feature
           */
          async update(id: string, input: UpdateFeatureInput): Promise<Feature> {
            const conn = getConnection();
            const now = new Date().toISOString();
            
            // Build SET clause dynamically
            const setClauses: string[] = ['f.updated_at = datetime($now)'];
            const params: Record<string, unknown> = { id, now };
            
            if (input.description !== undefined) {
              setClauses.push('f.description = $description');
              params.description = input.description;
            }
            if (input.category !== undefined) {
              setClauses.push('f.category = $category');
              params.category = input.category;
            }
            if (input.status !== undefined) {
              setClauses.push('f.status = $status');
              params.status = input.status;
              if (input.status === 'complete') {
                setClauses.push('f.completed_at = datetime($now)');
              }
            }
            if (input.steps !== undefined) {
              setClauses.push('f.steps = $steps');
              params.steps = input.steps;
            }
            if (input.priority !== undefined) {
              setClauses.push('f.priority = $priority');
              params.priority = input.priority;
            }
            if (input.assignedAgent !== undefined) {
              setClauses.push('f.assigned_agent = $assignedAgent');
              params.assignedAgent = input.assignedAgent;
            }
            if (input.confidence !== undefined) {
              setClauses.push('f.confidence = $confidence');
              params.confidence = input.confidence;
            }
            if (input.tokenCost !== undefined) {
              setClauses.push('f.token_cost = $tokenCost');
              params.tokenCost = input.tokenCost;
            }
            if (input.workCount !== undefined) {
              setClauses.push('f.work_count = $workCount');
              params.workCount = input.workCount;
            }
            
            const result = await conn.runQuery<{ f: Feature }>(
              `
              MATCH (f:Feature {id: $id})
              SET ${setClauses.join(', ')}
              RETURN f
              `,
              params,
              'WRITE'
            );
            
            return result[0].f;
          }
          
          /**
           * Start a feature (set to in_progress)
           */
          async startFeature(id: string, agent?: string): Promise<Feature> {
            return this.update(id, { 
              status: 'in_progress', 
              assignedAgent: agent 
            });
          }
          
          /**
           * Complete a feature
           */
          async completeFeature(id: string): Promise<Feature> {
            return this.update(id, { status: 'complete' });
          }
          
          /**
           * Block a feature
           */
          async blockFeature(id: string, reason?: string): Promise<Feature> {
            const conn = getConnection();
            const now = new Date().toISOString();
            
            const result = await conn.runQuery<{ f: Feature }>(
              `
              MATCH (f:Feature {id: $id})
              SET f.status = 'blocked',
                  f.updated_at = datetime($now),
                  f.block_reason = $reason
              RETURN f
              `,
              { id, now, reason: reason || '' },
              'WRITE'
            );
            
            return result[0].f;
          }
          
          /**
           * Increment work count for a feature
           */
          async incrementWorkCount(id: string): Promise<Feature> {
            const conn = getConnection();
            const now = new Date().toISOString();
            
            const result = await conn.runQuery<{ f: Feature }>(
              `
              MATCH (f:Feature {id: $id})
              SET f.work_count = f.work_count + 1,
                  f.updated_at = datetime($now)
              RETURN f
              `,
              { id, now },
              'WRITE'
            );
            
            return result[0].f;
          }
          
          /**
           * Link an event to a feature
           */
          async linkEvent(
            featureId: string, 
            eventId: string, 
            confidence: number = 1.0,
            linkedBy: 'auto' | 'manual' | 'agent' = 'auto'
          ): Promise<void> {
            const conn = getConnection();
            const now = new Date().toISOString();
            
            await conn.runQuery(
              `
              MATCH (f:Feature {id: $featureId})
              MATCH (e:Event {id: $eventId})
              MERGE (e)-[r:LINKED_TO]->(f)
              SET r.confidence = $confidence,
                  r.linked_by = $linkedBy,
                  r.linked_at = datetime($now)
              `,
              { featureId, eventId, confidence, linkedBy, now },
              'WRITE'
            );
          }
          
          /**
           * Get events linked to a feature
           */
          async getLinkedEvents(featureId: string, limit: number = 100): Promise<Event[]> {
            const conn = getConnection();
            const result = await conn.runQuery<{ e: Event }>(
              `
              MATCH (e:Event)-[:LINKED_TO]->(f:Feature {id: $featureId})
              RETURN e
              ORDER BY e.timestamp DESC
              LIMIT $limit
              `,
              { featureId, limit }
            );
            return result.map(r => r.e);
          }
          
          /**
           * Add dependency between features
           */
          async addDependency(
            featureId: string, 
            dependsOnId: string, 
            type: 'blocks' | 'requires' | 'related'
          ): Promise<void> {
            const conn = getConnection();
            
            await conn.runQuery(
              `
              MATCH (f:Feature {id: $featureId})
              MATCH (dep:Feature {id: $dependsOnId})
              MERGE (f)-[r:DEPENDS_ON]->(dep)
              SET r.dependency_type = $type
              `,
              { featureId, dependsOnId, type },
              'WRITE'
            );
          }
          
          /**
           * Get project statistics
           */
          async getProjectStats(projectId: string): Promise<{
            total: number;
            pending: number;
            inProgress: number;
            blocked: number;
            complete: number;
            completionPercentage: number;
          }> {
            const conn = getConnection();
            const result = await conn.runQuery<{
              total: number;
              pending: number;
              inProgress: number;
              blocked: number;
              complete: number;
            }>(
              `
              MATCH (f:Feature)-[:BELONGS_TO]->(p:Project {id: $projectId})
              RETURN 
                count(f) as total,
                sum(CASE WHEN f.status = 'pending' THEN 1 ELSE 0 END) as pending,
                sum(CASE WHEN f.status = 'in_progress' THEN 1 ELSE 0 END) as inProgress,
                sum(CASE WHEN f.status = 'blocked' THEN 1 ELSE 0 END) as blocked,
                sum(CASE WHEN f.status = 'complete' THEN 1 ELSE 0 END) as complete
              `,
              { projectId }
            );
            
            const stats = result[0] || { total: 0, pending: 0, inProgress: 0, blocked: 0, complete: 0 };
            return {
              ...stats,
              completionPercentage: stats.total > 0 
                ? Math.round((stats.complete / stats.total) * 100) 
                : 0
            };
          }
        }
        
        // Export singleton instance
        export const featureRepository = new FeatureRepository();
        
    - id: db-05
      name: "Create project repository"
      file: packages/graph-db/src/repositories/project.repository.ts
      description: |
        Similar structure to feature repository.
        Methods: create, getById, getByPath, getAll, update, delete
        
    - id: db-06
      name: "Create session repository"
      file: packages/graph-db/src/repositories/session.repository.ts
      description: |
        Similar structure to feature repository.
        Methods: create, getById, getActive, end, markStale, getByProject
        
    - id: db-07
      name: "Create event repository"
      file: packages/graph-db/src/repositories/event.repository.ts
      description: |
        Similar structure to feature repository.
        Methods: create, getById, getBySession, getByFeature, getRecent, search
        
    - id: db-08
      name: "Create insight repository"
      file: packages/graph-db/src/repositories/insight.repository.ts
      description: |
        Methods: create, search, getByTags, incrementUsage, getRelated
        
    - id: db-09
      name: "Create rule repository"
      file: packages/graph-db/src/repositories/rule.repository.ts
      description: |
        Methods: create, getByScope, getEnabled, update, toggle, incrementTriggerCount

    - id: db-10
      name: "Create SQLite cache sync service"
      file: packages/graph-db/src/sync/sqlite-cache.ts
      content: |
        /**
         * SQLite Cache Sync Service
         * 
         * Syncs data from Graph DB to local SQLite for fast UI reads.
         * This is ONE-WAY: Graph -> SQLite only.
         * 
         * NEVER write to SQLite from agents - use Graph DB via MCP tools.
         */
        
        import Database from 'better-sqlite3';
        import { getConnection } from '../connection';
        import type { Feature, Session, Event, Project } from '../types';
        
        export class SQLiteCacheSync {
          private db: Database.Database;
          private syncInterval: NodeJS.Timeout | null = null;
          
          constructor(dbPath: string) {
            this.db = new Database(dbPath);
            this.db.pragma('journal_mode = WAL');
            this.initSchema();
          }
          
          private initSchema(): void {
            this.db.exec(`
              -- Projects cache
              CREATE TABLE IF NOT EXISTS projects (
                id TEXT PRIMARY KEY,
                path TEXT UNIQUE NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                created_at TEXT,
                updated_at TEXT,
                settings TEXT,
                synced_at TEXT DEFAULT (datetime('now'))
              );
              
              -- Features cache
              CREATE TABLE IF NOT EXISTS features (
                id TEXT PRIMARY KEY,
                project_id TEXT NOT NULL,
                description TEXT NOT NULL,
                category TEXT NOT NULL,
                status TEXT NOT NULL DEFAULT 'pending',
                priority INTEGER DEFAULT 0,
                steps TEXT,
                completion_criteria TEXT,
                assigned_agent TEXT,
                confidence REAL,
                token_cost INTEGER,
                work_count INTEGER DEFAULT 0,
                error_count INTEGER DEFAULT 0,
                created_at TEXT,
                updated_at TEXT,
                completed_at TEXT,
                synced_at TEXT DEFAULT (datetime('now')),
                FOREIGN KEY (project_id) REFERENCES projects(id)
              );
              CREATE INDEX IF NOT EXISTS idx_features_project ON features(project_id);
              CREATE INDEX IF NOT EXISTS idx_features_status ON features(status);
              
              -- Sessions cache
              CREATE TABLE IF NOT EXISTS sessions (
                id TEXT PRIMARY KEY,
                project_id TEXT NOT NULL,
                agent TEXT NOT NULL,
                status TEXT NOT NULL,
                started_at TEXT,
                ended_at TEXT,
                last_activity TEXT,
                event_count INTEGER DEFAULT 0,
                model TEXT,
                is_subagent INTEGER DEFAULT 0,
                parent_session_id TEXT,
                synced_at TEXT DEFAULT (datetime('now')),
                FOREIGN KEY (project_id) REFERENCES projects(id)
              );
              CREATE INDEX IF NOT EXISTS idx_sessions_project ON sessions(project_id);
              CREATE INDEX IF NOT EXISTS idx_sessions_status ON sessions(status);
              
              -- Events cache (recent only, for timeline)
              CREATE TABLE IF NOT EXISTS events (
                id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                feature_id TEXT,
                event_type TEXT NOT NULL,
                tool_name TEXT,
                payload TEXT,
                summary TEXT,
                timestamp TEXT,
                success INTEGER,
                duration_ms INTEGER,
                tokens_used INTEGER,
                synced_at TEXT DEFAULT (datetime('now')),
                FOREIGN KEY (session_id) REFERENCES sessions(id),
                FOREIGN KEY (feature_id) REFERENCES features(id)
              );
              CREATE INDEX IF NOT EXISTS idx_events_session ON events(session_id);
              CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp DESC);
              CREATE INDEX IF NOT EXISTS idx_events_feature ON events(feature_id);
              
              -- Sync metadata
              CREATE TABLE IF NOT EXISTS sync_metadata (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at TEXT DEFAULT (datetime('now'))
              );
            `);
          }
          
          /**
           * Full sync from Graph DB
           * Call on app startup and periodically
           */
          async fullSync(): Promise<void> {
            const graphConn = getConnection();
            
            // Sync projects
            const projects = await graphConn.runQuery<{ p: Project }>(
              `MATCH (p:Project) RETURN p`
            );
            
            const insertProject = this.db.prepare(`
              INSERT OR REPLACE INTO projects 
              (id, path, name, description, created_at, updated_at, settings, synced_at)
              VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))
            `);
            
            for (const { p } of projects) {
              insertProject.run(
                p.id, p.path, p.name, p.description,
                p.created_at, p.updated_at, JSON.stringify(p.settings || {})
              );
            }
            
            // Sync features
            const features = await graphConn.runQuery<{ f: Feature; projectId: string }>(
              `
              MATCH (f:Feature)-[:BELONGS_TO]->(p:Project)
              RETURN f, p.id as projectId
              `
            );
            
            const insertFeature = this.db.prepare(`
              INSERT OR REPLACE INTO features
              (id, project_id, description, category, status, priority, steps, 
               completion_criteria, assigned_agent, confidence, token_cost, 
               work_count, error_count, created_at, updated_at, completed_at, synced_at)
              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
            `);
            
            for (const { f, projectId } of features) {
              insertFeature.run(
                f.id, projectId, f.description, f.category, f.status,
                f.priority || 0, JSON.stringify(f.steps || []),
                JSON.stringify(f.completion_criteria || {}),
                f.assigned_agent, f.confidence, f.token_cost,
                f.work_count || 0, f.error_count || 0,
                f.created_at, f.updated_at, f.completed_at
              );
            }
            
            // Sync recent sessions (last 7 days)
            const sessions = await graphConn.runQuery<{ s: Session; projectId: string }>(
              `
              MATCH (s:Session)-[:IN_PROJECT]->(p:Project)
              WHERE s.started_at > datetime() - duration('P7D')
              RETURN s, p.id as projectId
              `
            );
            
            const insertSession = this.db.prepare(`
              INSERT OR REPLACE INTO sessions
              (id, project_id, agent, status, started_at, ended_at, 
               last_activity, event_count, model, is_subagent, parent_session_id, synced_at)
              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
            `);
            
            for (const { s, projectId } of sessions) {
              insertSession.run(
                s.id, projectId, s.agent, s.status, s.started_at, s.ended_at,
                s.last_activity, s.event_count || 0, s.model,
                s.is_subagent ? 1 : 0, s.parent_session_id
              );
            }
            
            // Sync recent events (last 3 days, limit 10000)
            const events = await graphConn.runQuery<{ e: Event; sessionId: string; featureId: string | null }>(
              `
              MATCH (e:Event)-[:TRIGGERED_BY]->(s:Session)
              WHERE e.timestamp > datetime() - duration('P3D')
              OPTIONAL MATCH (e)-[:LINKED_TO]->(f:Feature)
              RETURN e, s.id as sessionId, f.id as featureId
              ORDER BY e.timestamp DESC
              LIMIT 10000
              `
            );
            
            const insertEvent = this.db.prepare(`
              INSERT OR REPLACE INTO events
              (id, session_id, feature_id, event_type, tool_name, payload, 
               summary, timestamp, success, duration_ms, tokens_used, synced_at)
              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
            `);
            
            for (const { e, sessionId, featureId } of events) {
              insertEvent.run(
                e.id, sessionId, featureId, e.event_type, e.tool_name,
                JSON.stringify(e.payload || {}), e.summary, e.timestamp,
                e.success ? 1 : 0, e.duration_ms, e.tokens_used
              );
            }
            
            // Update sync metadata
            this.db.prepare(`
              INSERT OR REPLACE INTO sync_metadata (key, value, updated_at)
              VALUES ('last_full_sync', datetime('now'), datetime('now'))
            `).run();
          }
          
          /**
           * Incremental sync for recent changes
           * Call more frequently (every 5-10 seconds)
           */
          async incrementalSync(since: string): Promise<void> {
            const graphConn = getConnection();
            
            // Only sync entities updated since last sync
            const features = await graphConn.runQuery<{ f: Feature; projectId: string }>(
              `
              MATCH (f:Feature)-[:BELONGS_TO]->(p:Project)
              WHERE f.updated_at > datetime($since)
              RETURN f, p.id as projectId
              `,
              { since }
            );
            
            // ... similar logic to fullSync but only for changed entities
            
            this.db.prepare(`
              INSERT OR REPLACE INTO sync_metadata (key, value, updated_at)
              VALUES ('last_incremental_sync', datetime('now'), datetime('now'))
            `).run();
          }
          
          /**
           * Start background sync loop
           */
          startSyncLoop(intervalMs: number = 5000): void {
            this.syncInterval = setInterval(async () => {
              try {
                const lastSync = this.db.prepare(
                  `SELECT value FROM sync_metadata WHERE key = 'last_incremental_sync'`
                ).get() as { value: string } | undefined;
                
                if (lastSync) {
                  await this.incrementalSync(lastSync.value);
                } else {
                  await this.fullSync();
                }
              } catch (error) {
                console.error('Sync error:', error);
              }
            }, intervalMs);
          }
          
          /**
           * Stop background sync loop
           */
          stopSyncLoop(): void {
            if (this.syncInterval) {
              clearInterval(this.syncInterval);
              this.syncInterval = null;
            }
          }
          
          /**
           * Close database connection
           */
          close(): void {
            this.stopSyncLoop();
            this.db.close();
          }
        }

    - id: db-11
      name: "Create shared TypeScript types"
      file: packages/graph-db/src/types.ts
      content: |
        /**
         * Shared Types for Ijoka
         * 
         * These types are the canonical definitions used across:
         * - Graph DB repositories
         * - SQLite cache
         * - MCP server
         * - Tauri frontend
         */
        
        // =============================================================================
        // ENUMS
        // =============================================================================
        
        export type FeatureStatus = 'pending' | 'in_progress' | 'blocked' | 'complete';
        
        export type FeatureCategory = 
          | 'functional' 
          | 'ui' 
          | 'security' 
          | 'performance' 
          | 'documentation' 
          | 'testing' 
          | 'infrastructure' 
          | 'refactoring';
        
        export type SessionStatus = 'active' | 'ended' | 'stale';
        
        export type AgentType = 'claude-code' | 'gemini-cli' | 'codex-cli' | 'unknown';
        
        export type RuleScope = 'global' | 'project' | 'feature';
        
        export type RuleEnforcement = 'hook' | 'prompt_inject' | 'reminder';
        
        export type InsightType = 'solution' | 'anti_pattern' | 'best_practice' | 'tool_usage';
        
        export type DependencyType = 'blocks' | 'requires' | 'related';
        
        export type LinkSource = 'auto' | 'manual' | 'agent';
        
        // =============================================================================
        // CORE ENTITIES
        // =============================================================================
        
        export interface Project {
          id: string;
          path: string;
          name: string;
          description?: string;
          created_at: string;
          updated_at: string;
          settings?: ProjectSettings;
        }
        
        export interface ProjectSettings {
          autoStartFeature?: boolean;
          defaultCompletionCriteria?: CompletionCriteria;
          enabledAgents?: AgentType[];
          customRules?: string[];
        }
        
        export interface Feature {
          id: string;
          description: string;
          category: FeatureCategory;
          status: FeatureStatus;
          priority: number;
          steps?: string[];
          completion_criteria?: CompletionCriteria;
          created_at: string;
          updated_at: string;
          completed_at?: string;
          work_count: number;
          assigned_agent?: string;
          confidence?: number;
          token_cost?: number;
          error_count: number;
          block_reason?: string;
        }
        
        export interface CompletionCriteria {
          type: 'manual' | 'build' | 'test' | 'lint' | 'work_count' | 'any_success';
          count?: number;
          command_pattern?: string;
          description?: string;
        }
        
        export interface Session {
          id: string;
          agent: AgentType;
          status: SessionStatus;
          started_at: string;
          ended_at?: string;
          last_activity: string;
          event_count: number;
          model?: string;
          is_subagent: boolean;
          parent_session_id?: string;
        }
        
        export interface Event {
          id: string;
          event_type: string;
          tool_name?: string;
          payload?: Record<string, unknown>;
          summary?: string;
          timestamp: string;
          success?: boolean;
          duration_ms?: number;
          tokens_used?: number;
        }
        
        export interface Insight {
          id: string;
          description: string;
          pattern_type: InsightType;
          tags?: string[];
          created_at: string;
          usage_count: number;
          effectiveness_score?: number;
        }
        
        export interface Rule {
          id: string;
          name: string;
          description: string;
          trigger: RuleTrigger;
          action: RuleAction;
          scope: RuleScope;
          enforcement: RuleEnforcement;
          enabled: boolean;
          created_at: string;
          triggered_count: number;
          source_instruction_count?: number;
        }
        
        export interface RuleTrigger {
          type: 'tool_use' | 'file_edit' | 'session_start' | 'prompt_pattern';
          pattern?: string;
          tool_name?: string;
          file_pattern?: string;
        }
        
        export interface RuleAction {
          type: 'run_command' | 'inject_prompt' | 'show_reminder' | 'block';
          command?: string;
          prompt?: string;
          message?: string;
        }
        
        // =============================================================================
        // RELATIONSHIP TYPES
        // =============================================================================
        
        export interface FeatureLink {
          eventId: string;
          featureId: string;
          confidence: number;
          linked_by: LinkSource;
          linked_at: string;
        }
        
        export interface FeatureDependency {
          featureId: string;
          dependsOnId: string;
          dependency_type: DependencyType;
        }
        
        // =============================================================================
        // API TYPES
        // =============================================================================
        
        export interface ProjectStats {
          total: number;
          pending: number;
          inProgress: number;
          blocked: number;
          complete: number;
          completionPercentage: number;
        }
        
        export interface SessionWithEvents extends Session {
          events: Event[];
        }
        
        export interface FeatureWithEvents extends Feature {
          events: Event[];
          dependencies?: Feature[];
        }
        
        // =============================================================================
        // MCP TOOL TYPES (for Phase 2)
        // =============================================================================
        
        export interface IjokaStatusResponse {
          project: {
            id: string;
            name: string;
            path: string;
          };
          current_feature: Feature | null;
          stats: ProjectStats;
          active_session: Session | null;
          recent_insights?: Insight[];
          active_blockers?: Feature[];
        }

    - id: db-12
      name: "Remove feature_list.json sync from watcher.rs"
      file: apps/desktop/src-tauri/src/watcher.rs
      action: modify
      description: |
        Remove all feature_list.json watching and syncing logic.
        The file watcher should now only:
        1. Watch for Graph DB sync notifications (if using file-based sync signals)
        2. Trigger UI refresh when cache is updated
        
        REMOVE:
        - sync_features_from_json()
        - feature_list.json file watching
        - JSON parsing logic
        
        KEEP:
        - Project directory watching for new projects
        - Configuration file watching
        
    - id: db-13
      name: "Update Rust backend to use SQLite as read cache only"
      files:
        - apps/desktop/src-tauri/src/db.rs
        - apps/desktop/src-tauri/src/commands.rs
      action: modify
      description: |
        Update all database operations:
        1. READ operations: Query SQLite cache (fast)
        2. WRITE operations: Should not exist in Rust backend
           - All writes go through MCP server -> Graph DB
           - SQLite is synced from Graph DB
        
        Remove from db.rs:
        - insert_feature()
        - update_feature()
        - complete_feature()
        - Any direct write operations
        
        Keep in db.rs:
        - get_features() (read from cache)
        - get_sessions() (read from cache)
        - get_events() (read from cache)
        - init_database() (creates cache tables)
        
    - id: db-14
      name: "Create graph DB migration from existing SQLite"
      file: packages/graph-db/src/migrations/from-sqlite.ts
      description: |
        One-time migration script to move existing SQLite data to Graph DB.
        
        Steps:
        1. Read all projects from old SQLite
        2. Read all features from old SQLite  
        3. Read all sessions from old SQLite
        4. Read all events from old SQLite
        5. Create nodes and relationships in Graph DB
        6. Mark migration as complete

  verification:
    - description: "Graph DB connection works"
      command: "pnpm --filter @ijoka/graph-db test:connection"
      
    - description: "Schema is initialized"
      command: "pnpm --filter @ijoka/graph-db test:schema"
      
    - description: "SQLite cache syncs correctly"
      command: "pnpm --filter @ijoka/graph-db test:sync"
      
    - description: "No feature_list.json references remain"
      command: "grep -r 'feature_list.json' --include='*.rs' --include='*.ts' ."
      expected: "No matches in non-migration code"

# ==============================================================================
# PHASE 2: MCP SERVER
# ==============================================================================
# Priority: High (enables agent communication without feature_list.json)
# Estimated Time: 10-16 hours
# Dependencies: Phase 1 (Database Architecture)
# ==============================================================================

phase_2_mcp_server:
  name: "MCP Server Implementation"
  priority: high
  estimated_hours: 16
  dependencies:
    - phase_1_database
    
  description: |
    Implement MCP (Model Context Protocol) server as the universal interface 
    for all agents to interact with Ijoka.
    
    This REPLACES feature_list.json as the way agents read/write state.
    
    Key Design Decisions:
    1. Tiered tool loading to minimize context overhead
    2. Single ijoka_status super-tool for efficient reads
    3. Explicit action tools for state changes
    4. Compatible with Claude Code, Gemini CLI, and Codex CLI

  architecture:
    server_type: "Standalone MCP server (stdio transport)"
    location: packages/mcp-server/
    
    tiers:
      tier_1:
        name: "Always Available"
        context_cost: "~200 tokens"
        tools:
          - ijoka_status
        description: "Minimal overhead, comprehensive read access"
        
      tier_2:
        name: "Feature Lifecycle"
        context_cost: "~300 tokens"
        activation: "Detected when intent is 'completing work' or 'starting task'"
        tools:
          - ijoka_start_feature
          - ijoka_complete_feature
          - ijoka_block_feature
          
      tier_3:
        name: "Learning & Insights"
        context_cost: "~400 tokens"  
        activation: "Skill-triggered or explicit request"
        tools:
          - ijoka_record_insight
          - ijoka_get_insights
          - ijoka_create_feature

  tools:
    - name: ijoka_status
      tier: 1
      description: |
        Get current project status, active task, and context.
        This is the primary read interface - returns comprehensive state in one call.
      parameters:
        - name: include_insights
          type: boolean
          default: false
          description: "Include relevant insights for current context"
        - name: include_blockers
          type: boolean
          default: false
          description: "Include list of blocked features"
        - name: project_path
          type: string
          required: false
          description: "Project path (defaults to current working directory)"
      returns:
        type: object
        schema: |
          {
            project: { id, name, path },
            current_feature: Feature | null,
            stats: { total, pending, inProgress, blocked, complete, completionPercentage },
            active_session: Session | null,
            recent_insights?: Insight[],
            active_blockers?: Feature[]
          }
      implementation_notes: |
        - Detect project from cwd if not specified
        - Return null for current_feature if none active
        - Stats should include completion percentage
        - Insights filtered by relevance to current work
        
    - name: ijoka_start_feature
      tier: 2
      description: |
        Start working on a feature. Sets status to 'in_progress' and assigns agent.
      parameters:
        - name: feature_id
          type: string
          required: false
          description: "Feature ID to start (uses next feature if not specified)"
        - name: agent
          type: string
          required: false
          description: "Agent identifier (auto-detected if not provided)"
      returns:
        type: object
        schema: |
          {
            success: boolean,
            feature: Feature,
            message: string
          }
      implementation_notes: |
        - If no feature_id, get next available (highest priority pending)
        - Check for blocking dependencies before starting
        - Create event for audit trail
        
    - name: ijoka_complete_feature
      tier: 2
      description: |
        Mark a feature as complete. Records completion event and updates stats.
      parameters:
        - name: feature_id
          type: string
          required: false
          description: "Feature ID to complete (uses current active if not specified)"
        - name: summary
          type: string
          required: false
          description: "Brief summary of what was done"
        - name: commit_hash
          type: string
          required: false
          description: "Git commit hash associated with completion"
      returns:
        type: object
        schema: |
          {
            success: boolean,
            feature: Feature,
            stats: ProjectStats,
            message: string
          }
          
    - name: ijoka_block_feature
      tier: 2
      description: |
        Report that work on a feature is blocked.
      parameters:
        - name: feature_id
          type: string
          required: false
          description: "Feature ID (uses current active if not specified)"
        - name: reason
          type: string
          required: true
          description: "Why the feature is blocked"
        - name: blocking_feature_id
          type: string
          required: false
          description: "If blocked by another feature, its ID"
      returns:
        type: object
        schema: |
          {
            success: boolean,
            feature: Feature,
            message: string
          }
          
    - name: ijoka_record_insight
      tier: 3
      description: |
        Record a reusable insight or learning from current work.
        These insights can be surfaced to future sessions working on similar tasks.
      parameters:
        - name: description
          type: string
          required: true
          description: "What was learned"
        - name: pattern_type
          type: string
          required: true
          enum: [solution, anti_pattern, best_practice, tool_usage]
          description: "Type of insight"
        - name: tags
          type: string[]
          required: false
          description: "Tags for categorization and search"
        - name: feature_id
          type: string
          required: false
          description: "Link to feature this insight came from"
      returns:
        type: object
        schema: |
          {
            success: boolean,
            insight: Insight,
            message: string
          }
          
    - name: ijoka_get_insights
      tier: 3
      description: |
        Get relevant insights for current work or by search query.
      parameters:
        - name: query
          type: string
          required: false
          description: "Search query"
        - name: tags
          type: string[]
          required: false
          description: "Filter by tags"
        - name: limit
          type: integer
          default: 5
          description: "Maximum insights to return"
      returns:
        type: array
        items: Insight
        
    - name: ijoka_create_feature
      tier: 3
      description: |
        Create a new feature in the project.
      parameters:
        - name: description
          type: string
          required: true
          description: "Feature description"
        - name: category
          type: string
          required: true
          enum: [functional, ui, security, performance, documentation, testing, infrastructure, refactoring]
          description: "Feature category"
        - name: steps
          type: string[]
          required: false
          description: "Verification steps"
        - name: priority
          type: integer
          required: false
          default: 0
          description: "Priority (higher = more important)"
        - name: depends_on
          type: string[]
          required: false
          description: "Feature IDs this depends on"
      returns:
        type: object
        schema: |
          {
            success: boolean,
            feature: Feature,
            message: string
          }
          
    - name: ijoka_record_event
      tier: internal
      description: |
        Internal tool for hooks to record events.
        Not exposed to agents directly - called by hook scripts.
      parameters:
        - name: event_type
          type: string
          required: true
        - name: tool_name
          type: string
          required: false
        - name: payload
          type: object
          required: false
        - name: session_id
          type: string
          required: true
        - name: feature_id
          type: string
          required: false
      returns:
        type: object
        schema: |
          {
            success: boolean,
            event_id: string
          }

  tasks:
    - id: mcp-01
      name: "Create packages/mcp-server directory structure"
      type: create_directory
      structure:
        packages/mcp-server/:
          - src/
          - src/tools/
          - src/handlers/
          - tests/
          - package.json
          - tsconfig.json
          - README.md
          
    - id: mcp-02
      name: "Create MCP server entry point"
      file: packages/mcp-server/src/index.ts
      content: |
        /**
         * Ijoka MCP Server
         * 
         * Model Context Protocol server for AI agent integration.
         * Provides tools for agents to read/write project state.
         * 
         * Transport: stdio (standard for MCP)
         * 
         * Usage:
         *   npx @ijoka/mcp-server
         *   
         * Configuration (Claude Code):
         *   Add to ~/.claude/settings.json:
         *   {
         *     "mcpServers": {
         *       "ijoka": {
         *         "command": "npx",
         *         "args": ["@ijoka/mcp-server"]
         *       }
         *     }
         *   }
         */
        
        import { Server } from '@modelcontextprotocol/sdk/server/index.js';
        import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
        import {
          CallToolRequestSchema,
          ListToolsRequestSchema,
          ListResourcesRequestSchema,
          ReadResourceRequestSchema,
        } from '@modelcontextprotocol/sdk/types.js';
        
        import { initGraphDB, closeGraphDB } from '@ijoka/graph-db';
        import { toolDefinitions, handleToolCall } from './tools';
        import { loadConfig } from './config';
        
        const server = new Server(
          {
            name: 'ijoka',
            version: '1.0.0',
          },
          {
            capabilities: {
              tools: {},
              resources: {},
            },
          }
        );
        
        // List available tools
        server.setRequestHandler(ListToolsRequestSchema, async () => {
          return {
            tools: toolDefinitions,
          };
        });
        
        // Handle tool calls
        server.setRequestHandler(CallToolRequestSchema, async (request) => {
          const { name, arguments: args } = request.params;
          
          try {
            const result = await handleToolCall(name, args || {});
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify(result, null, 2),
                },
              ],
            };
          } catch (error) {
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify({
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error',
                  }),
                },
              ],
              isError: true,
            };
          }
        });
        
        // List resources (projects, features as resources)
        server.setRequestHandler(ListResourcesRequestSchema, async () => {
          // TODO: Implement resource listing
          return { resources: [] };
        });
        
        // Read resource content
        server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
          // TODO: Implement resource reading
          return { contents: [] };
        });
        
        // Main entry point
        async function main() {
          const config = await loadConfig();
          
          // Initialize graph database connection
          await initGraphDB({
            uri: config.graphDbUri || 'bolt://localhost:7687',
            database: 'ijoka',
          });
          
          // Start MCP server
          const transport = new StdioServerTransport();
          await server.connect(transport);
          
          // Cleanup on exit
          process.on('SIGINT', async () => {
            await closeGraphDB();
            process.exit(0);
          });
        }
        
        main().catch((error) => {
          console.error('Failed to start Ijoka MCP server:', error);
          process.exit(1);
        });
        
    - id: mcp-03
      name: "Create tool definitions"
      file: packages/mcp-server/src/tools/definitions.ts
      content: |
        /**
         * MCP Tool Definitions
         * 
         * Defines the schema for all Ijoka tools.
         * These definitions are sent to the client on ListTools request.
         */
        
        import type { Tool } from '@modelcontextprotocol/sdk/types.js';
        
        export const toolDefinitions: Tool[] = [
          // ==========================================================================
          // TIER 1: Always Available (~200 tokens)
          // ==========================================================================
          {
            name: 'ijoka_status',
            description: `Get current project status, active task, and context.
        This is the primary read interface - returns comprehensive state in one call.
        Use this to understand what you're working on and project progress.`,
            inputSchema: {
              type: 'object',
              properties: {
                include_insights: {
                  type: 'boolean',
                  default: false,
                  description: 'Include relevant insights for current context',
                },
                include_blockers: {
                  type: 'boolean',
                  default: false,
                  description: 'Include list of blocked features',
                },
                project_path: {
                  type: 'string',
                  description: 'Project path (defaults to current working directory)',
                },
              },
              required: [],
            },
          },
          
          // ==========================================================================
          // TIER 2: Feature Lifecycle (~300 tokens)
          // ==========================================================================
          {
            name: 'ijoka_start_feature',
            description: `Start working on a feature. Sets status to 'in_progress' and assigns you.
        If no feature_id specified, starts the next available feature (highest priority pending).`,
            inputSchema: {
              type: 'object',
              properties: {
                feature_id: {
                  type: 'string',
                  description: 'Feature ID to start (uses next feature if not specified)',
                },
              },
              required: [],
            },
          },
          {
            name: 'ijoka_complete_feature',
            description: `Mark the current feature as complete.
        Records completion event and updates project statistics.`,
            inputSchema: {
              type: 'object',
              properties: {
                feature_id: {
                  type: 'string',
                  description: 'Feature ID (uses current active if not specified)',
                },
                summary: {
                  type: 'string',
                  description: 'Brief summary of what was done',
                },
                commit_hash: {
                  type: 'string',
                  description: 'Git commit hash associated with completion',
                },
              },
              required: [],
            },
          },
          {
            name: 'ijoka_block_feature',
            description: `Report that work on a feature is blocked.
        Use this when you encounter an obstacle you cannot resolve.`,
            inputSchema: {
              type: 'object',
              properties: {
                feature_id: {
                  type: 'string',
                  description: 'Feature ID (uses current active if not specified)',
                },
                reason: {
                  type: 'string',
                  description: 'Why the feature is blocked',
                },
                blocking_feature_id: {
                  type: 'string',
                  description: 'If blocked by another feature, its ID',
                },
              },
              required: ['reason'],
            },
          },
          
          // ==========================================================================
          // TIER 3: Learning & Insights (~400 tokens)
          // ==========================================================================
          {
            name: 'ijoka_record_insight',
            description: `Record a reusable insight or learning from current work.
        These insights are surfaced to future sessions working on similar tasks.`,
            inputSchema: {
              type: 'object',
              properties: {
                description: {
                  type: 'string',
                  description: 'What was learned',
                },
                pattern_type: {
                  type: 'string',
                  enum: ['solution', 'anti_pattern', 'best_practice', 'tool_usage'],
                  description: 'Type of insight',
                },
                tags: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Tags for categorization',
                },
              },
              required: ['description', 'pattern_type'],
            },
          },
          {
            name: 'ijoka_get_insights',
            description: `Get relevant insights for current work.
        Search past learnings that may help with the current task.`,
            inputSchema: {
              type: 'object',
              properties: {
                query: {
                  type: 'string',
                  description: 'Search query',
                },
                tags: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Filter by tags',
                },
                limit: {
                  type: 'integer',
                  default: 5,
                  description: 'Maximum insights to return',
                },
              },
              required: [],
            },
          },
          {
            name: 'ijoka_create_feature',
            description: `Create a new feature in the project.
        Use when you identify new work that should be tracked.`,
            inputSchema: {
              type: 'object',
              properties: {
                description: {
                  type: 'string',
                  description: 'Feature description',
                },
                category: {
                  type: 'string',
                  enum: ['functional', 'ui', 'security', 'performance', 'documentation', 'testing', 'infrastructure', 'refactoring'],
                  description: 'Feature category',
                },
                steps: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Verification steps',
                },
                priority: {
                  type: 'integer',
                  default: 0,
                  description: 'Priority (higher = more important)',
                },
                depends_on: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Feature IDs this depends on',
                },
              },
              required: ['description', 'category'],
            },
          },
        ];
        
    - id: mcp-04
      name: "Create tool handlers"
      file: packages/mcp-server/src/tools/handlers.ts
      description: |
        Implement the actual logic for each tool.
        Each handler:
        1. Validates input
        2. Calls appropriate repository methods
        3. Creates audit events
        4. Returns structured response
        
    - id: mcp-05
      name: "Create MCP server package.json"
      file: packages/mcp-server/package.json
      content: |
        {
          "name": "@ijoka/mcp-server",
          "version": "1.0.0",
          "description": "Ijoka MCP Server - Model Context Protocol interface for AI agents",
          "main": "dist/index.js",
          "bin": {
            "ijoka-mcp": "dist/index.js"
          },
          "scripts": {
            "build": "tsc",
            "dev": "tsx watch src/index.ts",
            "start": "node dist/index.js",
            "test": "vitest",
            "typecheck": "tsc --noEmit"
          },
          "dependencies": {
            "@modelcontextprotocol/sdk": "^1.0.0",
            "@ijoka/graph-db": "workspace:*",
            "zod": "^3.22.0"
          },
          "devDependencies": {
            "@types/node": "^20.0.0",
            "tsx": "^4.0.0",
            "typescript": "^5.3.0",
            "vitest": "^1.0.0"
          },
          "engines": {
            "node": ">=18.0.0"
          }
        }
        
    - id: mcp-06
      name: "Update Claude plugin to use MCP instead of HTTP"
      files:
        - packages/claude-plugin/hooks/scripts/session-start.py
        - packages/claude-plugin/hooks/scripts/track-event.py
        - packages/claude-plugin/hooks/scripts/db_helper.py
      action: modify
      description: |
        Update hook scripts to communicate via MCP instead of HTTP API.
        
        Options:
        A) Keep hooks simple, have them call MCP tools via subprocess
        B) Have hooks write to a queue that MCP server processes
        C) Keep HTTP for hooks (internal), MCP for agent tools
        
        RECOMMENDED: Option C
        - Hooks use HTTP to internal Ijoka API (fast, local)
        - Agents use MCP tools (standard interface)
        - Both write to same Graph DB
        
    - id: mcp-07
      name: "Create Claude Code MCP configuration documentation"
      file: packages/mcp-server/docs/claude-code-setup.md
      content: |
        # Setting up Ijoka with Claude Code
        
        ## Installation
        
        1. Install the Ijoka MCP server globally:
        ```bash
        npm install -g @ijoka/mcp-server
        ```
        
        2. Add to Claude Code settings (`~/.claude/settings.json`):
        ```json
        {
          "mcpServers": {
            "ijoka": {
              "command": "npx",
              "args": ["@ijoka/mcp-server"],
              "env": {
                "IJOKA_GRAPH_DB_URI": "bolt://localhost:7687"
              }
            }
          }
        }
        ```
        
        3. Restart Claude Code
        
        ## Usage
        
        Once configured, Claude Code will have access to Ijoka tools:
        
        - `ijoka_status` - Get project status and current task
        - `ijoka_start_feature` - Start working on a feature
        - `ijoka_complete_feature` - Mark feature as complete
        - `ijoka_block_feature` - Report blocked feature
        - `ijoka_record_insight` - Save learnings
        - `ijoka_get_insights` - Retrieve past learnings
        - `ijoka_create_feature` - Add new features
        
        ## Example Session
        
        ```
        You: What should I work on?
        
        Claude: Let me check the project status.
        [Calls ijoka_status]
        
        Based on the status, you have 5 pending features. The highest priority is:
        "Implement user authentication"
        
        Would you like me to start working on this feature?
        
        You: Yes
        
        Claude: [Calls ijoka_start_feature]
        
        Started working on "Implement user authentication". I'll now...
        ```

  verification:
    - description: "MCP server starts without errors"
      command: "npx @ijoka/mcp-server --help"
      
    - description: "Tool definitions are valid"
      command: "pnpm --filter @ijoka/mcp-server test:tools"
      
    - description: "Integration with Claude Code works"
      manual: true
      steps:
        - "Configure MCP server in Claude Code settings"
        - "Start Claude Code session"
        - "Ask Claude to call ijoka_status"
        - "Verify response includes project info"

# ==============================================================================
# PHASE 3: EVENT SOURCING MIGRATION
# ==============================================================================
# Priority: Medium (improves reliability, needed for rules engine)
# Estimated Time: 6-10 hours
# Dependencies: Phase 1 (Database), Phase 2 (MCP Server)
# ==============================================================================

phase_3_event_sourcing:
  name: "Event Sourcing Migration"
  priority: medium
  estimated_hours: 10
  dependencies:
    - phase_1_database
    - phase_2_mcp_server
    
  description: |
    Migrate from mutable state to event sourcing pattern.
    
    Instead of: UPDATE feature SET status = 'complete'
    We append:  INSERT event (feature_completed, feature_id, timestamp)
    
    Current state is COMPUTED from event history.
    
    Benefits:
    - Full audit trail automatically
    - No lost updates
    - Easy debugging (replay events)
    - Multi-agent safe (append-only)
    - Time-travel queries (state at any point)

  event_types:
    project:
      - ProjectCreated
      - ProjectUpdated
      - ProjectArchived
      
    feature:
      - FeatureCreated
      - FeatureStarted
      - FeatureCompleted
      - FeatureBlocked
      - FeatureUnblocked
      - FeatureUpdated
      - FeaturePriorityChanged
      - FeatureWorkCountIncremented
      - FeatureDependencyAdded
      - FeatureDependencyRemoved
      
    session:
      - SessionStarted
      - SessionEnded
      - SessionMarkedStale
      
    tool:
      - ToolCallRecorded
      - ToolCallLinkedToFeature
      
    insight:
      - InsightRecorded
      - InsightUsed
      
    rule:
      - RuleCreated
      - RuleEnabled
      - RuleDisabled
      - RuleTriggered

  event_schema:
    base:
      - { field: event_id, type: string, description: "UUID" }
      - { field: event_type, type: string, description: "One of the types above" }
      - { field: aggregate_type, type: string, description: "project, feature, session, etc" }
      - { field: aggregate_id, type: string, description: "ID of the entity this event affects" }
      - { field: timestamp, type: datetime, description: "When event occurred" }
      - { field: actor, type: string, description: "Who/what caused this event (agent, user, system)" }
      - { field: payload, type: json, description: "Event-specific data" }
      - { field: metadata, type: json, description: "Context (session_id, project_id, etc)" }

  tasks:
    - id: es-01
      name: "Create event store in Graph DB"
      file: packages/graph-db/src/repositories/event-store.repository.ts
      description: |
        Append-only event store with:
        - append(event): Add event to store
        - getEvents(aggregateId, since?): Get events for an entity
        - getAllEvents(since?): Get all events since timestamp
        - replayEvents(aggregateId): Replay events to rebuild state
        
    - id: es-02
      name: "Create state projections from events"
      file: packages/graph-db/src/projections/feature.projection.ts
      description: |
        Project current feature state from events:
        
        function computeFeatureState(featureId: string): Feature {
          const events = eventStore.getEvents(featureId);
          
          let state = { status: 'pending', work_count: 0, ... };
          
          for (const event of events) {
            switch (event.type) {
              case 'FeatureStarted':
                state.status = 'in_progress';
                state.assigned_agent = event.payload.agent;
                break;
              case 'FeatureCompleted':
                state.status = 'complete';
                state.completed_at = event.timestamp;
                break;
              // ... etc
            }
          }
          
          return state;
        }
        
    - id: es-03
      name: "Update repositories to use event sourcing"
      files:
        - packages/graph-db/src/repositories/feature.repository.ts
        - packages/graph-db/src/repositories/session.repository.ts
      description: |
        Modify write operations to append events instead of direct mutations.
        Read operations compute state from events (with caching).
        
    - id: es-04
      name: "Create event handlers for side effects"
      file: packages/graph-db/src/handlers/event-handlers.ts
      description: |
        React to events for side effects:
        - FeatureCompleted -> Update project stats, trigger notification
        - SessionStarted -> Check for stale sessions
        - InsightRecorded -> Index for search
        
    - id: es-05
      name: "Update SQLite cache to sync from events"
      file: packages/graph-db/src/sync/event-based-sync.ts
      description: |
        Instead of querying current state, process event stream:
        - Subscribe to new events
        - Apply events to SQLite projections
        - Maintain sync cursor (last processed event)

  verification:
    - description: "Events are appended correctly"
      command: "pnpm --filter @ijoka/graph-db test:events"
      
    - description: "State is computed correctly from events"
      command: "pnpm --filter @ijoka/graph-db test:projections"
      
    - description: "Event replay produces correct state"
      command: "pnpm --filter @ijoka/graph-db test:replay"

# ==============================================================================
# PHASE 4: UI ENHANCEMENTS
# ==============================================================================
# Priority: Medium (improves user experience)
# Estimated Time: 12-20 hours
# Dependencies: Phase 1 (Database)
# ==============================================================================

phase_4_ui:
  name: "UI Enhancements - Multi-View Architecture"
  priority: medium
  estimated_hours: 20
  dependencies:
    - phase_1_database
    
  description: |
    Add new views and improve existing ones:
    
    Current Views:
    - Kanban View (exists)
    - Activity Timeline (exists)
    
    New Views:
    - Graph View (feature dependencies, relationships)
    - Timeline View (Gantt-style feature timeline)
    - Table View (sortable, filterable feature list)
    - Rules Dashboard (observability → rules pipeline)
    
    Also improve:
    - Feature-Activity linking visibility
    - Session grouping and navigation
    - Real-time updates

  components:
    existing_improvements:
      KanbanBoard:
        file: apps/desktop/src/components/KanbanBoard.vue
        improvements:
          - "Add drag-and-drop between columns"
          - "Show dependency indicators on cards"
          - "Add quick actions (start, complete, block)"
          - "Improve card design with more info"
          
      ActivityTimeline:
        file: apps/desktop/src/components/ActivityTimeline.vue
        improvements:
          - "Better feature linking visualization"
          - "Click event to see linked feature"
          - "Filter by event type"
          - "Search events"
          
      FeatureDetailModal:
        file: apps/desktop/src/components/FeatureDetailModal.vue
        improvements:
          - "Show linked events timeline"
          - "Display dependencies graph"
          - "Edit feature properties"
          - "Quick status actions"
          
    new_views:
      GraphView:
        file: apps/desktop/src/components/views/GraphView.vue
        description: |
          Visual graph of features and their relationships.
          Uses D3.js or vis-network for rendering.
        features:
          - "Feature nodes with status colors"
          - "Dependency edges (blocks, requires, related)"
          - "Click node to select feature"
          - "Zoom and pan"
          - "Filter by status/category"
          - "Highlight blocked chains"
        implementation: |
          <template>
            <div class="graph-view" ref="container">
              <div class="graph-controls">
                <select v-model="filter.status">
                  <option value="">All Status</option>
                  <option value="pending">Pending</option>
                  <option value="in_progress">In Progress</option>
                  <option value="blocked">Blocked</option>
                  <option value="complete">Complete</option>
                </select>
                <button @click="fitToScreen">Fit to Screen</button>
                <button @click="resetView">Reset</button>
              </div>
              <div class="graph-canvas" ref="canvas"></div>
              <FeatureDetailSidebar 
                v-if="selectedFeature" 
                :feature="selectedFeature"
                @close="selectedFeature = null"
              />
            </div>
          </template>
          
      TimelineView:
        file: apps/desktop/src/components/views/TimelineView.vue
        description: |
          Gantt-style timeline showing feature progress over time.
        features:
          - "Features as horizontal bars"
          - "Color by status"
          - "Show start/end dates"
          - "Dependency lines"
          - "Zoom in/out (day, week, month)"
          - "Today indicator"
          
      TableView:
        file: apps/desktop/src/components/views/TableView.vue
        description: |
          Sortable, filterable table of all features.
        features:
          - "Sort by any column"
          - "Filter by status, category, agent"
          - "Search descriptions"
          - "Bulk actions (select multiple)"
          - "Inline editing"
          - "Export to CSV"
        implementation: |
          <template>
            <div class="table-view">
              <div class="table-toolbar">
                <input 
                  v-model="searchQuery" 
                  placeholder="Search features..."
                  class="search-input"
                />
                <div class="filters">
                  <FilterDropdown 
                    v-model="filters.status" 
                    :options="statusOptions" 
                    label="Status"
                  />
                  <FilterDropdown 
                    v-model="filters.category" 
                    :options="categoryOptions"
                    label="Category"
                  />
                </div>
                <div class="bulk-actions" v-if="selectedCount > 0">
                  <span>{{ selectedCount }} selected</span>
                  <button @click="bulkStart">Start All</button>
                  <button @click="bulkComplete">Complete All</button>
                </div>
              </div>
              
              <table class="features-table">
                <thead>
                  <tr>
                    <th class="checkbox-col">
                      <input type="checkbox" v-model="selectAll" />
                    </th>
                    <th @click="sortBy('description')" :class="sortClass('description')">
                      Description
                    </th>
                    <th @click="sortBy('category')" :class="sortClass('category')">
                      Category
                    </th>
                    <th @click="sortBy('status')" :class="sortClass('status')">
                      Status
                    </th>
                    <th @click="sortBy('priority')" :class="sortClass('priority')">
                      Priority
                    </th>
                    <th @click="sortBy('work_count')" :class="sortClass('work_count')">
                      Work Count
                    </th>
                    <th @click="sortBy('updated_at')" :class="sortClass('updated_at')">
                      Updated
                    </th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  <tr 
                    v-for="feature in filteredFeatures" 
                    :key="feature.id"
                    :class="{ selected: isSelected(feature.id) }"
                  >
                    <td><input type="checkbox" v-model="selected" :value="feature.id" /></td>
                    <td>{{ feature.description }}</td>
                    <td><CategoryBadge :category="feature.category" /></td>
                    <td><StatusBadge :status="feature.status" /></td>
                    <td>{{ feature.priority }}</td>
                    <td>{{ feature.work_count }}</td>
                    <td>{{ formatDate(feature.updated_at) }}</td>
                    <td>
                      <FeatureActions :feature="feature" />
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </template>
          
      RulesDashboard:
        file: apps/desktop/src/components/views/RulesDashboard.vue
        description: |
          Dashboard for the observability → rules pipeline.
          Shows detected patterns and allows promotion to rules.
        features:
          - "Detected instruction patterns"
          - "Promotion to rules"
          - "Active rules list"
          - "Rule effectiveness metrics"
          - "Enable/disable rules"
          - "Edit rule configuration"
        sections:
          - name: "Detected Patterns"
            description: |
              Shows repeated instructions that could become rules.
              Example: "You've given 'run tests' instruction 8 times"
              Button: [Promote to Rule] [Dismiss]
          - name: "Active Rules"
            description: |
              List of enabled rules with:
              - Name and description
              - Trigger count
              - Enforcement type (hook, prompt, reminder)
              - Toggle switch
          - name: "Rule Editor"
            description: |
              Create/edit rules with:
              - Name, description
              - Trigger conditions
              - Action configuration
              - Scope selection

    shared_components:
      description: "Reusable components extracted for DRY architecture"
      components:
        - name: StatusBadge
          file: apps/desktop/src/components/shared/StatusBadge.vue
          props: [status]
          description: "Colored badge showing feature status"
          
        - name: CategoryBadge
          file: apps/desktop/src/components/shared/CategoryBadge.vue
          props: [category]
          description: "Colored badge showing feature category"
          
        - name: FeatureCard
          file: apps/desktop/src/components/shared/FeatureCard.vue
          props: [feature, compact?, showActions?]
          description: "Unified feature card used in Kanban and elsewhere"
          
        - name: FeatureActions
          file: apps/desktop/src/components/shared/FeatureActions.vue
          props: [feature]
          events: [start, complete, block, edit]
          description: "Action buttons for feature operations"
          
        - name: FilterDropdown
          file: apps/desktop/src/components/shared/FilterDropdown.vue
          props: [modelValue, options, label, multiple?]
          description: "Reusable filter dropdown"
          
        - name: EventCard
          file: apps/desktop/src/components/shared/EventCard.vue
          props: [event, compact?]
          description: "Event display card with tool icon and summary"
          
        - name: SessionCard
          file: apps/desktop/src/components/shared/SessionCard.vue
          props: [session, expanded?]
          events: [toggle, select]
          description: "Session grouping card"
          
        - name: EmptyState
          file: apps/desktop/src/components/shared/EmptyState.vue
          props: [icon, title, description, actionLabel?, actionHandler?]
          description: "Empty state placeholder"
          
        - name: LoadingSpinner
          file: apps/desktop/src/components/shared/LoadingSpinner.vue
          props: [size?, label?]
          description: "Loading indicator"
          
        - name: ConfirmDialog
          file: apps/desktop/src/components/shared/ConfirmDialog.vue
          props: [title, message, confirmLabel?, cancelLabel?]
          events: [confirm, cancel]
          description: "Confirmation dialog"

    composables:
      description: "Vue 3 composables for shared logic"
      composables:
        - name: useFeatures
          file: apps/desktop/src/composables/useFeatures.ts
          description: |
            Feature state management composable.
            - features: Ref<Feature[]>
            - loading: Ref<boolean>
            - error: Ref<string | null>
            - refresh(): Promise<void>
            - getByStatus(status): Feature[]
            - startFeature(id): Promise<void>
            - completeFeature(id): Promise<void>
            
        - name: useSessions
          file: apps/desktop/src/composables/useSessions.ts
          description: |
            Session state management composable.
            - sessions: Ref<Session[]>
            - activeSessions: ComputedRef<Session[]>
            - getSessionEvents(id): Event[]
            
        - name: useStats
          file: apps/desktop/src/composables/useStats.ts
          description: |
            Project statistics composable.
            - stats: Ref<ProjectStats>
            - completionPercentage: ComputedRef<number>
            
        - name: useFilters
          file: apps/desktop/src/composables/useFilters.ts
          description: |
            Generic filtering composable.
            - filters: Ref<Record<string, unknown>>
            - applyFilters(items): T[]
            - resetFilters(): void
            
        - name: useSort
          file: apps/desktop/src/composables/useSort.ts
          description: |
            Generic sorting composable.
            - sortBy: Ref<string>
            - sortOrder: Ref<'asc' | 'desc'>
            - sortedItems: ComputedRef<T[]>
            - toggleSort(field): void

  tasks:
    - id: ui-01
      name: "Extract shared components"
      description: |
        Create the shared components directory and extract common UI elements.
        Each component should:
        - Have TypeScript props interface
        - Use scoped CSS
        - Include basic tests
        - Be documented with usage examples
        
    - id: ui-02
      name: "Create composables"
      description: |
        Create Vue 3 composables for shared state logic.
        Each composable should:
        - Have full TypeScript types
        - Handle loading and error states
        - Support real-time updates via events
        
    - id: ui-03
      name: "Implement Graph View"
      description: |
        Create the GraphView component with D3.js or vis-network.
        Steps:
        1. Install visualization library
        2. Create basic node rendering
        3. Add edge rendering for dependencies
        4. Implement zoom/pan
        5. Add node click selection
        6. Add filters
        
    - id: ui-04
      name: "Implement Timeline View"
      description: |
        Create Gantt-style timeline view.
        Consider using a library like vue-gantt or building custom.
        
    - id: ui-05
      name: "Implement Table View"
      description: |
        Create sortable, filterable table view.
        
    - id: ui-06
      name: "Implement Rules Dashboard"
      description: |
        Create the observability → rules pipeline UI.
        
    - id: ui-07
      name: "Add view switcher to App.vue"
      file: apps/desktop/src/App.vue
      description: |
        Update the activity bar to include all view options:
        - Board (Kanban)
        - Graph
        - Timeline
        - Table
        - Rules
        - Activity (sidebar - already exists)
        
    - id: ui-08
      name: "Improve feature-activity linking"
      description: |
        Make the connection between features and activities more visible:
        - In Activity Timeline: Show feature badge on events
        - In Feature Detail: Show linked events
        - Click event → highlight feature
        - Click feature → filter events
        
    - id: ui-09
      name: "Add real-time updates"
      description: |
        Ensure all views update in real-time when data changes:
        - Subscribe to Tauri events
        - Update reactive state
        - Smooth transitions (no jarring refreshes)

  verification:
    - description: "All shared components render correctly"
      command: "pnpm --filter ijoka-desktop test:components"
      
    - description: "All views load without errors"
      manual: true
      steps:
        - "Open app"
        - "Switch to each view"
        - "Verify data displays correctly"
        
    - description: "Real-time updates work"
      manual: true
      steps:
        - "Open app"
        - "Run Claude Code in another terminal"
        - "Verify events appear in real-time"

# ==============================================================================
# PHASE 5: PLUGIN CONSOLIDATION (Absorb Contextune)
# ==============================================================================
# Priority: Medium (improves functionality, can be done later)
# Estimated Time: 8-14 hours
# Dependencies: Phase 2 (MCP Server)
# ==============================================================================

phase_5_plugin_consolidation:
  name: "Plugin Consolidation - Absorb Contextune"
  priority: medium
  estimated_hours: 14
  dependencies:
    - phase_2_mcp_server
    
  description: |
    Merge Contextune functionality into the Ijoka plugin.
    This is NOT an integration - it's consolidation under unified branding.
    
    Contextune provides:
    - Intent detection (3-tier cascade)
    - Haiku agent delegation
    - Smart tool routing
    - DRY strategy framework
    - Session duration tracking
    - Cost optimization
    
    These become part of Ijoka's Claude Code plugin.

  contextune_features_to_absorb:
    intent_detection:
      description: |
        3-tier cascade for detecting user intent:
        1. Keyword matching (0.02ms) - 60% coverage
        2. Model2Vec embeddings (0.2ms) - 30% coverage  
        3. Semantic router (50ms) - 10% coverage
      location: contextune/src/intent/
      target: packages/claude-plugin/hooks/scripts/intent_detection.py
      
    haiku_delegation:
      description: |
        Delegate expensive operations to Haiku for cost savings:
        - Read operations >1000 lines
        - Complex bash commands
        - Parallel task execution
      location: contextune/src/agents/
      target: packages/claude-plugin/agents/
      note: "Creates .claude/agents/ directory with agent definitions"
      
    tool_routing:
      description: |
        Smart routing decisions:
        - Token estimation for operations
        - Cost-benefit analysis
        - Delegation vs direct execution
      location: contextune/src/routing/
      target: packages/claude-plugin/hooks/scripts/tool_routing.py
      
    dry_strategy:
      description: |
        Decision framework for DRY content:
        - When to use YAML modules vs static docs
        - Token-based estimation
        - Extraction patterns
      location: contextune/UNIFIED_DRY_STRATEGY.md
      target: packages/claude-plugin/skills/dry-strategy/SKILL.md
      
    cost_tracking:
      description: |
        Session cost monitoring:
        - Token usage per operation
        - Model costs
        - Session totals
      location: contextune/src/metrics/
      target: packages/claude-plugin/hooks/scripts/cost_tracking.py

  tasks:
    - id: plugin-01
      name: "Review Contextune codebase"
      description: |
        Examine Contextune at /Users/shakes/DevProjects/contextune/ to understand:
        - Current architecture
        - What can be directly copied
        - What needs adaptation
        
    - id: plugin-02
      name: "Create intent detection module"
      file: packages/claude-plugin/hooks/scripts/intent_detection.py
      description: |
        Port the 3-tier intent detection cascade.
        Used by UserPromptSubmit hook to understand what user wants.
        
    - id: plugin-03
      name: "Create Haiku agent definitions"
      files:
        - packages/claude-plugin/agents/parallel-task-executor.md
        - packages/claude-plugin/agents/worktree-manager.md
        - packages/claude-plugin/agents/issue-orchestrator.md
        - packages/claude-plugin/agents/test-runner.md
        - packages/claude-plugin/agents/performance-analyzer.md
      description: |
        Port the 5 specialized Haiku agents from Contextune.
        These go in .claude/agents/ when plugin is installed.
        
    - id: plugin-04
      name: "Create tool routing module"
      file: packages/claude-plugin/hooks/scripts/tool_routing.py
      description: |
        Smart routing decisions for PreToolUse hook:
        - Estimate operation cost
        - Decide: direct vs delegate
        - Route to appropriate agent
        
    - id: plugin-05
      name: "Create DRY strategy skill"
      file: packages/claude-plugin/skills/dry-strategy/SKILL.md
      description: |
        Decision framework for when to:
        - Use modular YAML files
        - Extract to static documentation
        - Use deterministic scripts
        
    - id: plugin-06
      name: "Create cost tracking module"
      file: packages/claude-plugin/hooks/scripts/cost_tracking.py
      description: |
        Track costs per session:
        - Token usage
        - Model costs
        - Cumulative totals
        Send to Ijoka for display in UI.
        
    - id: plugin-07
      name: "Update hooks to use new modules"
      files:
        - packages/claude-plugin/hooks/scripts/session-start.py
        - packages/claude-plugin/hooks/scripts/track-event.py
        - packages/claude-plugin/hooks/hooks.json
      description: |
        Integrate the new modules into existing hooks:
        - UserPromptSubmit: Use intent detection
        - PreToolUse: Use tool routing
        - PostToolUse: Update cost tracking
        - SessionStart: Initialize tracking
        - SessionEnd: Report totals
        
    - id: plugin-08
      name: "Create additional skills"
      files:
        - packages/claude-plugin/skills/feature-workflow/SKILL.md
        - packages/claude-plugin/skills/testing-workflow/SKILL.md
        - packages/claude-plugin/skills/research-workflow/SKILL.md
        - packages/claude-plugin/skills/code-review/SKILL.md
      description: |
        Additional skills for guided workflows.
        These can be activated by intent detection.
        
    - id: plugin-09
      name: "Create additional commands"
      files:
        - packages/claude-plugin/commands/cost-report.md
        - packages/claude-plugin/commands/delegate-task.md
        - packages/claude-plugin/commands/optimize-context.md
      description: |
        Commands that leverage the new functionality.
        
    - id: plugin-10
      name: "Update plugin README"
      file: packages/claude-plugin/README.md
      description: |
        Document all features:
        - Intent detection
        - Cost optimization
        - Haiku delegation
        - Available commands
        - Available skills
        - Available agents

  verification:
    - description: "Intent detection works"
      manual: true
      steps:
        - "Install plugin"
        - "Start Claude Code session"
        - "Submit various prompts"
        - "Check hook logs for intent classification"
        
    - description: "Cost tracking works"
      manual: true
      steps:
        - "Run Claude Code session"
        - "Check Ijoka UI for cost display"
        
    - description: "Haiku delegation works"
      manual: true
      steps:
        - "Request operation that should delegate"
        - "Verify Haiku agent handles it"

# ==============================================================================
# PHASE 6: RULES ENGINE
# ==============================================================================
# Priority: Low (advanced feature, do last)
# Estimated Time: 10-16 hours
# Dependencies: Phase 3 (Event Sourcing), Phase 5 (Plugin Consolidation)
# ==============================================================================

phase_6_rules_engine:
  name: "Rules Engine - Observability to Rules Pipeline"
  priority: low
  estimated_hours: 16
  dependencies:
    - phase_3_event_sourcing
    - phase_5_plugin_consolidation
    
  description: |
    Implement the observability → rules pipeline.
    
    Flow:
    1. DETECT: Observe repeated instructions in sessions
    2. SUGGEST: Show patterns in Rules Dashboard
    3. PROMOTE: User clicks to create rule
    4. ENFORCE: Rule triggers on matching conditions
    
    Example:
    - User says "run tests" 8 times across sessions
    - Dashboard shows: "Detected pattern: 'run tests after changes'"
    - User clicks [Promote to Rule]
    - Rule created: "After editing .ts files, run pnpm test"
    - Future sessions automatically run tests

  pattern_detection:
    instruction_patterns:
      - pattern: "run (the )?tests?"
        category: testing
        suggested_rule: "Run tests after code changes"
        
      - pattern: "search (the )?(web|online)"
        category: research
        suggested_rule: "Search web when encountering unknown errors"
        
      - pattern: "don'?t (repeat|duplicate)"
        category: dry
        suggested_rule: "Check for existing utilities before creating new"
        
      - pattern: "check (the )?lint"
        category: quality
        suggested_rule: "Run linter after changes"
        
      - pattern: "commit (the )?changes"
        category: git
        suggested_rule: "Commit after completing task"

  rule_types:
    hook_enforced:
      description: "Automatic execution via hooks"
      example:
        trigger: { type: file_edit, pattern: "*.ts" }
        action: { type: run_command, command: "pnpm test" }
      enforcement: PostToolUse hook runs command automatically
      
    prompt_injected:
      description: "Reminder injected into context"
      example:
        trigger: { type: session_start }
        action: { type: inject_prompt, prompt: "Remember to run tests after changes" }
      enforcement: SessionStart hook adds to additionalContext
      
    contextual_reminder:
      description: "Triggered reminder at specific moments"
      example:
        trigger: { type: tool_use, tool_name: "Write" }
        action: { type: show_reminder, message: "Consider adding tests for new code" }
      enforcement: PreToolUse hook shows reminder before write

  tasks:
    - id: rules-01
      name: "Create pattern detection service"
      file: packages/graph-db/src/services/pattern-detection.ts
      description: |
        Analyze session events to detect repeated patterns:
        - Query user messages for instruction patterns
        - Count occurrences across sessions
        - Rank by frequency
        
    - id: rules-02
      name: "Create rules repository"
      file: packages/graph-db/src/repositories/rule.repository.ts
      description: |
        Already defined in Phase 1, implement fully:
        - create(rule)
        - getEnabled(scope)
        - update(id, changes)
        - toggle(id)
        - incrementTriggerCount(id)
        
    - id: rules-03
      name: "Create rule engine service"
      file: packages/graph-db/src/services/rule-engine.ts
      description: |
        Evaluate and execute rules:
        - matchRules(context): Find applicable rules
        - executeRule(rule): Perform rule action
        - logTrigger(rule): Record that rule fired
        
    - id: rules-04
      name: "Integrate rules into hooks"
      files:
        - packages/claude-plugin/hooks/scripts/session-start.py
        - packages/claude-plugin/hooks/scripts/track-event.py
      description: |
        Query and apply rules at hook execution:
        - SessionStart: Load prompt-injected rules
        - PreToolUse: Check for pre-action rules
        - PostToolUse: Check for post-action rules
        
    - id: rules-05
      name: "Create rules API endpoints"
      files:
        - apps/desktop/src-tauri/src/server.rs
        - apps/desktop/src-tauri/src/commands.rs
      description: |
        API endpoints for rules management:
        - GET /rules - List rules
        - POST /rules - Create rule
        - PUT /rules/:id - Update rule
        - DELETE /rules/:id - Delete rule
        - POST /rules/:id/toggle - Enable/disable
        - GET /patterns - Get detected patterns
        
    - id: rules-06
      name: "Complete Rules Dashboard UI"
      file: apps/desktop/src/components/views/RulesDashboard.vue
      description: |
        Already outlined in Phase 4, implement fully:
        - Pattern detection display
        - Rule creation flow
        - Rule management
        - Effectiveness metrics

  verification:
    - description: "Pattern detection finds repeated instructions"
      manual: true
      steps:
        - "Create test sessions with repeated instructions"
        - "Check Rules Dashboard for detected patterns"
        
    - description: "Rules can be created and enabled"
      manual: true
      steps:
        - "Promote a pattern to rule"
        - "Verify rule appears in active rules"
        
    - description: "Rules are enforced"
      manual: true
      steps:
        - "Create a PostToolUse rule"
        - "Trigger the condition"
        - "Verify action executes"

# ==============================================================================
# EXECUTION ORDER AND DEPENDENCIES
# ==============================================================================

execution_plan:
  overview: |
    Execute phases in order, respecting dependencies.
    Each phase has verification steps - do not proceed until verified.
    
    Total Estimated Time: 64-92 hours (8-12 days at 8 hours/day)
    
  order:
    - phase: phase_0_rename
      estimated_hours: 4
      can_parallelize: false
      notes: "Must be done first to avoid confusion"
      
    - phase: phase_1_database
      estimated_hours: 12
      can_parallelize: false
      notes: "Foundation for everything else"
      
    - phase: phase_2_mcp_server
      estimated_hours: 16
      can_parallelize: false
      notes: "Enables agent communication without feature_list.json"
      
    - phase: phase_3_event_sourcing
      estimated_hours: 10
      can_parallelize: true
      parallel_with: phase_4_ui
      notes: "Can be done in parallel with UI work"
      
    - phase: phase_4_ui
      estimated_hours: 20
      can_parallelize: true
      parallel_with: phase_3_event_sourcing
      notes: "Can start once Phase 1 is done"
      
    - phase: phase_5_plugin_consolidation
      estimated_hours: 14
      can_parallelize: false
      notes: "Depends on MCP server being stable"
      
    - phase: phase_6_rules_engine
      estimated_hours: 16
      can_parallelize: false
      notes: "Advanced feature, do last"

  milestones:
    - name: "v0.1.0 - Renamed & Database Migration"
      phases: [phase_0_rename, phase_1_database]
      deliverables:
        - "Project renamed to Ijoka"
        - "Graph DB as source of truth"
        - "SQLite as cache"
        - "feature_list.json eliminated"
        
    - name: "v0.2.0 - MCP Integration"
      phases: [phase_2_mcp_server]
      deliverables:
        - "MCP server operational"
        - "Claude Code can use Ijoka tools"
        - "Agents no longer need feature_list.json"
        
    - name: "v0.3.0 - Enhanced UI"
      phases: [phase_4_ui]
      deliverables:
        - "Graph View"
        - "Timeline View"
        - "Table View"
        - "Improved components"
        
    - name: "v0.4.0 - Event Sourcing"
      phases: [phase_3_event_sourcing]
      deliverables:
        - "Append-only events"
        - "State projection"
        - "Full audit trail"
        
    - name: "v0.5.0 - Plugin Consolidation"
      phases: [phase_5_plugin_consolidation]
      deliverables:
        - "Intent detection"
        - "Haiku delegation"
        - "Cost tracking"
        - "Additional skills"
        
    - name: "v1.0.0 - Rules Engine"
      phases: [phase_6_rules_engine]
      deliverables:
        - "Pattern detection"
        - "Rule creation"
        - "Automatic enforcement"
        - "Rules Dashboard"

# ==============================================================================
# DEVELOPMENT GUIDELINES
# ==============================================================================

development_guidelines:
  code_style:
    typescript:
      - "Use strict mode"
      - "No any types - use unknown and narrow"
      - "Prefer interfaces over types for object shapes"
      - "Use const assertions for literal types"
      - "Document public APIs with JSDoc"
      
    python:
      - "Use type hints on all functions"
      - "Use Pydantic for data validation"
      - "Use dataclasses or Pydantic models for DTOs"
      - "Follow PEP 8"
      - "Use docstrings"
      
    rust:
      - "Run clippy with pedantic"
      - "Use Result for fallible operations"
      - "Prefer &str over String in function parameters"
      - "Document public items"
      
    vue:
      - "Use Composition API with <script setup>"
      - "Define props with TypeScript interfaces"
      - "Use defineEmits with type parameters"
      - "Scoped CSS only"
      - "Keep components under 200 lines"

  testing:
    unit_tests:
      - "Test pure functions"
      - "Test edge cases"
      - "Mock external dependencies"
      
    integration_tests:
      - "Test database operations"
      - "Test API endpoints"
      - "Test MCP tools"
      
    e2e_tests:
      - "Test critical user flows"
      - "Test real-time updates"
      
  commits:
    format: "type(scope): description"
    types:
      - feat: New feature
      - fix: Bug fix
      - refactor: Code refactoring
      - docs: Documentation
      - test: Tests
      - chore: Maintenance
    examples:
      - "feat(mcp): add ijoka_status tool"
      - "fix(ui): correct feature card overflow"
      - "refactor(db): extract repository pattern"

  pr_checklist:
    - "TypeScript compiles without errors"
    - "Rust compiles without warnings"
    - "All tests pass"
    - "No console.log or dbg! left in code"
    - "Types are complete (no any)"
    - "New components have tests"
    - "Documentation updated if needed"

# ==============================================================================
# APPENDIX: FILE REFERENCE
# ==============================================================================

file_reference:
  packages:
    graph-db:
      description: "Graph database connection, repositories, sync"
      files:
        - src/index.ts
        - src/connection.ts
        - src/types.ts
        - src/schema/init.cypher
        - src/repositories/feature.repository.ts
        - src/repositories/project.repository.ts
        - src/repositories/session.repository.ts
        - src/repositories/event.repository.ts
        - src/repositories/insight.repository.ts
        - src/repositories/rule.repository.ts
        - src/repositories/event-store.repository.ts
        - src/projections/feature.projection.ts
        - src/sync/sqlite-cache.ts
        - src/sync/event-based-sync.ts
        - src/services/pattern-detection.ts
        - src/services/rule-engine.ts
        - src/migrations/from-sqlite.ts
        
    mcp-server:
      description: "MCP server for agent communication"
      files:
        - src/index.ts
        - src/config.ts
        - src/tools/definitions.ts
        - src/tools/handlers.ts
        - src/tools/index.ts
        - docs/claude-code-setup.md
        - docs/gemini-cli-setup.md
        - docs/codex-cli-setup.md
        
    claude-plugin:
      description: "Claude Code plugin with hooks, commands, skills, agents"
      files:
        - hooks/hooks.json
        - hooks/scripts/db_helper.py
        - hooks/scripts/session-start.py
        - hooks/scripts/session-end.py
        - hooks/scripts/track-event.py
        - hooks/scripts/intent_detection.py
        - hooks/scripts/tool_routing.py
        - hooks/scripts/cost_tracking.py
        - commands/*.md
        - skills/*/SKILL.md
        - agents/*.md
        
  apps:
    desktop:
      description: "Tauri desktop application"
      frontend:
        - src/App.vue
        - src/main.ts
        - src/components/KanbanBoard.vue
        - src/components/KanbanColumn.vue
        - src/components/ActivityTimeline.vue
        - src/components/views/GraphView.vue
        - src/components/views/TimelineView.vue
        - src/components/views/TableView.vue
        - src/components/views/RulesDashboard.vue
        - src/components/shared/*.vue
        - src/composables/*.ts
      backend:
        - src-tauri/src/main.rs
        - src-tauri/src/db.rs
        - src-tauri/src/server.rs
        - src-tauri/src/watcher.rs
        - src-tauri/src/commands.rs

# ==============================================================================
# PHASE 5: MIGRATION FROM FEATURE_LIST.JSON (Critical Path)
# ==============================================================================
# This phase ELIMINATES feature_list.json entirely
# ==============================================================================

phase_5_eliminate_feature_list_json:
  name: "Eliminate feature_list.json - Graph DB as Single Source of Truth"
  priority: critical
  estimated_hours: 8
  
  description: |
    CRITICAL: This phase completely removes feature_list.json from the workflow.
    After this phase, features exist ONLY in the graph database.
    
    Migration Path:
    1. One-time import: Read existing feature_list.json into graph
    2. Update all hooks to use graph_client instead of file operations
    3. Remove file watcher for feature_list.json
    4. Delete all code that reads/writes feature_list.json
    5. Update agent instructions to use MCP tools
    
    Source of Truth After Migration:
    ┌─────────────────────────────────────────────────────────────────┐
    │                    GRAPH DB (Memgraph)                          │
    │                    Source of Truth                              │
    │  • Features (nodes)                                             │
    │  • Dependencies (relationships)                                 │
    │  • Events (append-only)                                         │
    │  • Sessions, Rules, Insights                                    │
    └─────────────────────────────────────────────────────────────────┘
                               │
                     Sync (real-time or polling)
                               ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    SQLITE CACHE                                 │
    │                    Read-Only for Tauri UI                       │
    │  • Denormalized feature list                                    │
    │  • Recent events                                                │
    │  • Session summaries                                            │
    └─────────────────────────────────────────────────────────────────┘
                               │
                     Tauri IPC Commands
                               ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    TAURI FRONTEND (Vue)                         │
    │  • Reads from SQLite cache                                      │
    │  • Never writes directly to any database                        │
    │  • Sends commands via IPC to backend                            │
    └─────────────────────────────────────────────────────────────────┘

  tasks:
    - id: migrate-01
      name: "Create migration script for existing feature_list.json files"
      files:
        - path: packages/core/src/migrations/from-json.ts
          purpose: |
            One-time migration that:
            1. Reads feature_list.json from project directories
            2. Creates Feature nodes in graph for each entry
            3. Preserves status (maps passes/in_progress to FeatureStatus)
            4. Creates DEPENDS_ON relationships if detected
            5. Renames file to feature_list.json.migrated
            
    - id: migrate-02
      name: "Update hooks to use graph_client.py exclusively"
      files_to_modify:
        - path: packages/claude-plugin/hooks/scripts/session-start.py
          changes:
            - "Remove: sync_features_from_json()"
            - "Add: graph.get_or_create_project(project_path)"
            - "Add: features = graph.get_features(project_path)"
            
        - path: packages/claude-plugin/hooks/scripts/track-event.py
          changes:
            - "Remove: Any feature_list.json file operations"
            - "Add: graph.append_event(event)"
            - "Add: graph.link_event_to_feature(event_id, feature_id)"
            
    - id: migrate-03
      name: "Remove feature_list.json file watcher from Tauri"
      files_to_modify:
        - path: apps/desktop/src-tauri/src/watcher.rs
          changes:
            - "Remove: watch for 'feature_list.json' changes"
            - "Add: graph change subscription (polling or CDC)"
            
    - id: migrate-04
      name: "Update agent commands to use MCP tools"
      files_to_modify:
        - path: packages/claude-plugin/commands/init-project.md
          changes:
            - "Remove: Instructions to create feature_list.json"
            - "Add: Instructions to use ijoka_status and MCP tools"
            - "Add: Example workflow using ijoka_start_feature"
            
        - path: packages/claude-plugin/CLAUDE.md
          changes:
            - "Remove: References to feature_list.json"
            - "Add: MCP tool usage instructions"
            - "Add: Ijoka workflow documentation"
            
    - id: migrate-05
      name: "Delete all feature_list.json related code"
      files_to_delete:
        - packages/claude-plugin/hooks/scripts/validate-feature-edit.py
        - packages/claude-plugin/hooks/scripts/sync_features.py
        
      code_to_remove:
        - pattern: "feature_list.json"
          files: "all"
          action: "Remove or replace with graph operations"

  verification:
    - command: "grep -r 'feature_list.json' packages/ apps/"
      expected: "No matches (file reference eliminated)"
    - command: "Test migration on existing project with feature_list.json"
      expected: "Features imported to graph, JSON file renamed"
    - command: "Start session, verify graph contains features"
      expected: "Features queryable via MCP tools"

# ==============================================================================
# PHASE 6: CONTEXTUNE ABSORPTION
# ==============================================================================
# Merge all Contextune functionality into unified Ijoka plugin
# ==============================================================================

phase_6_contextune_absorption:
  name: "Absorb Contextune into Ijoka Plugin"
  priority: high
  estimated_hours: 12
  
  description: |
    This is NOT an integration - it's absorbing Contextune functionality
    into the Ijoka plugin with unified branding.
    
    Components to absorb:
    1. Intent Detection (3-tier cascade)
    2. Haiku Agent Delegation
    3. Smart Tool Routing
    4. DRY Strategies
    5. Token Cost Tracking
    6. Session Duration Monitoring
    
    Post-absorption, Contextune as a separate entity ceases to exist.
    Everything is branded as "Ijoka".

  tasks:
    - id: absorb-01
      name: "Copy intent detection module"
      source: contextune/intent_detection.py
      destination: packages/claude-plugin/hooks/scripts/intent_detection.py
      changes:
        - "Rename imports from contextune to ijoka"
        - "Update module docstring with Ijoka branding"
        - "Integrate with graph_client for rule-based intent hints"
        
    - id: absorb-02
      name: "Copy smart routing module"
      source: contextune/smart_routing.py
      destination: packages/claude-plugin/hooks/scripts/smart_routing.py
      changes:
        - "Rename to ijoka branding"
        - "Add graph-based routing rules"
        - "Integrate with Ijoka MCP server"
        
    - id: absorb-03
      name: "Copy Haiku delegation module"
      source: contextune/haiku_delegation.py
      destination: packages/claude-plugin/hooks/scripts/haiku_delegation.py
      changes:
        - "Rename to ijoka branding"
        - "Log delegation events to graph"
        - "Track cost savings in session metadata"
        
    - id: absorb-04
      name: "Copy cost tracking module"
      source: contextune/cost_tracking.py
      destination: packages/claude-plugin/hooks/scripts/cost_tracking.py
      changes:
        - "Rename to ijoka branding"
        - "Store cost data in graph events"
        - "Add projection for cost dashboard"
        
    - id: absorb-05
      name: "Merge DRY strategies into skills"
      source: contextune/dry_strategies.yaml
      destination: packages/claude-plugin/skills/dry-principles/SKILL.md
      changes:
        - "Convert YAML strategies to Markdown skill format"
        - "Add Ijoka-specific examples"
        
    - id: absorb-06
      name: "Merge agents into Ijoka agents directory"
      source: contextune/agents/
      destination: packages/claude-plugin/agents/
      changes:
        - "Rename agents with ijoka prefix"
        - "Update tool references to use Ijoka MCP tools"
        
    - id: absorb-07
      name: "Delete Contextune as separate package"
      action: |
        After all functionality is absorbed and verified:
        1. Remove contextune/ directory
        2. Remove contextune references from package.json
        3. Update all imports to use ijoka paths

  verification:
    - command: "python -c 'from ijoka_mcp.intent_detection import detect_intent; print(detect_intent(\"start feature\"))'"
      expected: "IntentResult(category=START_FEATURE, ...)"
    - command: "Check no contextune references remain"
      expected: "All renamed to ijoka"

# ==============================================================================
# PHASE 7: RULES DASHBOARD
# ==============================================================================
# Observability → Rules pipeline UI
# ==============================================================================

phase_7_rules_dashboard:
  name: "Rules Dashboard - Observability to Rules Pipeline"
  priority: medium
  estimated_hours: 16
  
  description: |
    Create the UI for the observability → rules pipeline.
    This is the key differentiating feature of Ijoka.
    
    The dashboard shows:
    1. Repeated instructions detected
    2. Promotable patterns (seen N+ times)
    3. Active rules with enforcement status
    4. Rule effectiveness metrics

  ui_mockup: |
    ┌─────────────────────────────────────────────────────────────────┐
    │ RULES DASHBOARD                                    [+ New Rule] │
    ├─────────────────────────────────────────────────────────────────┤
    │                                                                 │
    │ DETECTED PATTERNS (Ready to Promote)                            │
    │ ┌─────────────────────────────────────────────────────────────┐ │
    │ │ 🔄 "Run tests after UI changes"           8x   [Promote →]  │ │
    │ │ 🔄 "Search web if stuck > 3 attempts"     5x   [Promote →]  │ │
    │ │ 🔄 "Check existing utils before new"      4x   [Promote →]  │ │
    │ └─────────────────────────────────────────────────────────────┘ │
    │                                                                 │
    │ ACTIVE RULES                                                    │
    │ ┌─────────────────────────────────────────────────────────────┐ │
    │ │ ✅ Run pnpm test after *.vue changes  [Hook]  100% enforced │ │
    │ │ ✅ Commit after each feature          [Prompt] 87% followed │ │
    │ │ ⚠️  Use TypeScript strict mode        [Reminder] 65% follow │ │
    │ └─────────────────────────────────────────────────────────────┘ │
    │                                                                 │
    │ RULE EFFECTIVENESS                                              │
    │ ┌─────────────────────────────────────────────────────────────┐ │
    │ │ Total Rules: 12   Active: 8   Triggered Today: 24           │ │
    │ │ Estimated Time Saved: ~45 min (from repeated instructions)  │ │
    │ └─────────────────────────────────────────────────────────────┘ │
    └─────────────────────────────────────────────────────────────────┘

  tasks:
    - id: rules-01
      name: "Create pattern detection service"
      files:
        - path: packages/core/src/services/pattern-detection.ts
          purpose: |
            Analyze user prompts for repeated instruction patterns.
            Uses regex + semantic similarity to cluster similar instructions.
            
    - id: rules-02
      name: "Create RulesDashboard.vue component"
      files:
        - path: apps/desktop/src/components/views/RulesDashboard.vue
          
    - id: rules-03
      name: "Create rule promotion flow"
      files:
        - path: apps/desktop/src/components/RulePromotionModal.vue
        - path: packages/core/src/services/rule-promotion.ts
        
    - id: rules-04
      name: "Create rule effectiveness tracking"
      files:
        - path: packages/core/src/projections/rule-effectiveness.ts

# ==============================================================================
# EXECUTION SUMMARY
# ==============================================================================

execution_summary:
  total_estimated_hours: 96
  recommended_order:
    - phase: "Phase 0: Rename"
      hours: 4
      critical: true
      
    - phase: "Phase 1: Graph Database"
      hours: 16
      critical: true
      notes: "Foundation for everything else"
      
    - phase: "Phase 5: Eliminate feature_list.json"
      hours: 8
      critical: true
      notes: "Must complete before MCP server is useful"
      
    - phase: "Phase 2: MCP Server"
      hours: 16
      critical: true
      notes: "Universal agent interface"
      
    - phase: "Phase 6: Contextune Absorption"
      hours: 12
      critical: false
      notes: "Can be done in parallel with UI work"
      
    - phase: "Phase 4: UI Enhancements"
      hours: 24
      critical: false
      notes: "Graph View, Timeline View, Table View"
      
    - phase: "Phase 7: Rules Dashboard"
      hours: 16
      critical: false
      notes: "Key differentiating feature"

  milestones:
    - name: "v1.0.0-alpha"
      includes:
        - "Phase 0: Rename complete"
        - "Phase 1: Graph DB operational"
        - "Phase 5: feature_list.json eliminated"
      deliverable: "Basic graph-backed Ijoka with SQLite cache"
      
    - name: "v1.0.0-beta"
      includes:
        - "Phase 2: MCP Server operational"
        - "Phase 6: Contextune absorbed"
      deliverable: "Full MCP integration, intent detection, cost tracking"
      
    - name: "v1.0.0"
      includes:
        - "Phase 4: Multi-view UI"
        - "Phase 7: Rules Dashboard"
      deliverable: "Complete Ijoka with all views and observability→rules"

  key_commands:
    start_memgraph: "docker run -p 7687:7687 memgraph/memgraph"
    run_migrations: "pnpm --filter @ijoka/core run migrate"
    start_mcp_server: "ijoka-mcp --project ."
    start_desktop: "pnpm --filter @ijoka/desktop run tauri dev"
    run_tests: "pnpm test"
